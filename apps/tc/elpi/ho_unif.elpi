namespace link {
  pred eta-expand i:term, i:term, o:term.  
  eta-expand T1 Ty (fun _ Ty B) :- is-coq-term T1, !, pi x\ coq.mk-app T1 [x] (B x). 
  eta-expand T1 Ty (fun _ Ty R) :- pi x\ name (R x) T1 [x].

  pred unify-under-fun i:any, i:term.
  unify-under-fun A (fun _ _ B) :- !,
    std.unsafe-cast A A', pi x\ unify-under-fun (A' x) (B x).
  unify-under-fun A B :- A = B.

  :index (_ _ 1)
  pred may-contract-to i:list term, i:term, i:term.
  may-contract-to _ N N :- !.
  may-contract-to L N V :- var V _ S, !, std.forall [N|L] (std.mem! S).
  may-contract-to L N (app [N|A]) :-
    std.length A {std.length L},
    std.forall2 {std.rev L} A (may-contract-to []).
  may-contract-to L N (fun _ _ B) :-
    pi x\ may-contract-to [x|L] N (B x).

  pred occurs-rigidly i:term, i:term.
  occurs-rigidly N N.
  occurs-rigidly N (app A) :- exists! A (occurs-rigidly N).
  occurs-rigidly N (fun _ _ B) :- pi x\ occurs-rigidly N (B x).

  pred maybe-eta-aux i:term, i:list term.
  maybe-eta-aux V L :- var V _ S, std.forall L (std.mem! S).
  maybe-eta-aux (app [_|A]) L :-
    SplitLen is {std.length A} - {std.length L},
    split-at-not-fatal SplitLen A HD TL,
    std.forall L (x\ not (exists! HD (occurs-rigidly x))),
    std.forall2 {std.rev L} TL (may-contract-to []). 
  maybe-eta-aux (fun _ _ B) L :-
    pi x\ maybe-eta-aux (B x) [x|L].

  pred maybe-eta i:term.
  maybe-eta (fun _ _ B) :- pi x\ maybe-eta-aux (B x) [x].

  pred progress-eta-left-aux i:term, i:term.
  progress-eta-left-aux (fun _ _ A) (fun _ _ A') :- !, pi x\ progress-eta-left-aux (A x) (A' x).
  progress-eta-left-aux A (fun _ _ _ as T) :- !, link.eta-expand A _ Ae, pi x\ progress-eta-left-aux Ae T.
  progress-eta-left-aux A A' :- A = A'.

  pred progress-eta-left i:term, o:term.
  progress-eta-left A _ :- var A, !, fail.
  progress-eta-left (fun _ _ A) (fun _ _ B) :- var B, !, A = B.
  progress-eta-left A A' :- (name A; is-coq-term A), !, eta-expand A _ A'.

  pred progress-eta-right i:term, o:term.
  progress-eta-right A A' :- coq.reduction.eta-contract A A', not (A = A'), !.
  progress-eta-right A A :- not (maybe-eta A), !.

  pred scope-check i:term, i:term.
  scope-check (uvar _ L) T :- prune A L, A = T, !.

  pred get-vars i:term, o:list term.
  get-vars T R :-
    (pi X H L Ign\ fold-map X L X [H|L] :- var X H Ign, !) => 
      fold-map T [] _ R.

  pred eta i:term, i:term.
  eta _ B :- var B, coq.error "link.eta error, flexible rhs".
  % TODO: Next rule is for goals of the form `link.eta {{f}} {{fun x y => f x y}}`
  %       Is it possible to have `link.eta {{f}} {{fun x y => lp:(X y x)}}`, if so, this breaks eta progression
  eta A (fun _ _ B as T) :- not (var A), not (var B), !, progress-eta-left-aux A T. 
  eta A B :- progress-eta-right B B', !, A = B'. 
  eta A B :- progress-eta-left A A', !, A' = B.
  eta A B :- scope-check A B, get-vars B L, declare_constraint (eta A B) [A|L].
}

pred relocate i:list term, i:list term, i:term, o:term.
relocate [] [] T T' :- copy T T', coq.say "Copy result is" T T'.
relocate [X|Xs] [Y|Ys] T T' :-
  coq.say "Charging" (copy Y X),
  (copy Y X :- !) => relocate Xs Ys T T'.

  % constraint link.eta uvar relocate fun {
  %   rule (N1 : G1 ?- link.eta (uvar X L1) (fun _ T1 B1)) 
  %      \ (N2 : G2 ?- link.eta (uvar X L2) (fun _ T2 B2)) 
  %      | (
  %         pi x\ relocate L1 L2 (B2 x) (B2' x),
  %         coq.say "Will unify" B1 "and" B2',
  %         std.spy(B1 = B2')
  %       )  
  %   <=> (N1 : G1 ?- B1 = B2').
  % }
  
pred count-prod i:term , o:nat.
count-prod (prod _ _ B) (s N) :- !, pi x\ count-prod (B x) N.
count-prod _ z.

% [var-mem F Ar H Ty]
% we associate the FO variable F, to the HO variable H 
% with airty Ar and type Ty
pred var-mem o:term, o:any, o:nat, o:term.

pred locally-bound o:term.
pred is-uvar o:term.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% [tc.maybe-eta-tm T Scope] indicates that T is a maybe-eta. Scope is the list of FV occurring in T 
% type tc.maybe-eta-tm term -> list term -> term.

% Note: [fo-to-ho-aux T L T' L'] extends fold-map for ho compilation
%       recursive call should be done calling the fold-map predicate!
pred fo-to-ho-aux1 i:term, i:nat, o:term, o:nat.

pred free-var o:list term.
free-var L :-
  std.findall (locally-bound _) T,
  std.map T (x\y\ x = locally-bound y) L.

pred maybe-eta-aux-compilation i:term, i:list term.
maybe-eta-aux-compilation (app [H|S]) L :- is-uvar H, !, 
  std.forall L (x\ exists! S (y\ link.may-contract-to [] x y)).

pred may-contract-to-aux-compilation i:list term, i:term, i:term.
may-contract-to-aux-compilation L N (app [H|S]) :- is-uvar H, !, 
  std.forall [N|L] (x\ exists! S (y\ link.may-contract-to [] x y)).

fo-to-ho-aux1 (fun Name Ty B) N (tc.maybe-eta-tm (fun Name Ty B') Scope) (s M) :-
  free-var Scope,
  (pi T L\ link.maybe-eta-aux T L :- maybe-eta-aux-compilation T L, !) => 
  (pi L N T\ link.may-contract-to L N T :- may-contract-to-aux-compilation L N T) =>
    (pi x\ link.maybe-eta-aux (B x) [x]), !,
  (pi x\ locally-bound x => fold-map (B x) N (B' x) M).

fo-to-ho-aux1 (fun Name Ty B) N (fun Name Ty B') M :- !,
  pi x\ locally-bound x => fold-map (B x) N (B' x) M.

pred precompile-maybe-eta i:term, o:term, o:nat.
precompile-maybe-eta T T1 N :-
  (pi x y l1 l2\ fold-map x l1 y l2 :- fo-to-ho-aux1 x l1 y l2, !) =>
    fold-map T z T1 N.

% [close-term-ty (x\ L) Ty R] Ty is the type of x
pred close-term-ty i:(term -> list prop), i:term, o:list prop.
close-term-ty (x\ []) _ [] :- !.
close-term-ty (x\ [X | Xs x]) Ty [X| Xs'] :- !, close-term-ty Xs Ty Xs'.
close-term-ty (x\ [X x | Xs x]) Ty [@pi-decl `x` Ty x\ X x | Xs'] :- !, close-term-ty Xs Ty Xs'. 

pred build-links-aux i:term, i:pair (list term) (list prop), o:term, o:pair (list term) (list prop).
build-links-aux (tc.maybe-eta-tm T S) (pr [X|XS] L1) Y (pr XS' [NL | L2]) :-
  name Y X S,
  fold-map T (pr XS L1) T' (pr XS' L2), 
  NL = link.eta Y T'.

build-links-aux (fun Name Ty Bo) (pr XS L) (fun Name Ty Bo') (pr XS' L') :- !,
  (pi x\ locally-bound x => fold-map (Bo x) (pr XS L) (Bo' x) (pr XS' (L'' x))),
  close-term-ty L'' Ty L'.

build-links-aux (prod Name Ty Bo) (pr XS L) (prod Name Ty Bo') (pr XS' L') :- !,
  (pi x\ locally-bound x => fold-map (Bo x) (pr XS L) (Bo' x) (pr XS' (L'' x))),
  close-term-ty L'' Ty L'.

build-links-aux (app [T|L]) N R N :-
  std.forall L locally-bound,
  distinct_names L,
  length L Len,
  var-mem T V Len Ty_, !,
  std.unsafe-cast V V',
  name R V' L.

pred build-links i:term, i:list term, o:term, o:list prop, o:list term.
build-links T L R Links L' :-
  (pi x y l1 l2\ fold-map x l1 y l2 :- build-links-aux x l1 y l2, !) =>
    fold-map T (pr L []) R (pr L' Links).