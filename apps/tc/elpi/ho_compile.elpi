namespace tc {
  namespace compile {

    namespace instance {
      
      namespace decompile {

        pred decompile-term-aux i:term, i:pair (list term) (list prop), o:term, o:pair (list term) (list prop).
        decompile-term-aux (tc.maybe-eta-tm T S) (pr [X|XS] L1) Y (pr XS' [NL | L2]) :-
          name Y X S, !,
          fold-map T (pr XS L1) T' (pr XS' L2), 
          NL = link.eta Y T'.

        % TODO: here decompile maybe-llam-tm
        % decompile-term-aux (tc.maybe-llam-tm H PF NPF S) (pr [X|XS] L1) Y (pr XS' [NL | L2]) :- fail,
        %   name Y X S, !,
        %   fold-map NPF1 (pr XS L1) T' (pr XS' L2), 
        %   NL = link.eta Y T'.

        decompile-term-aux (fun Name Ty Bo) (pr XS L) (fun Name Ty Bo') (pr XS' L') :- !,
          (pi x\ locally-bound x => fold-map (Bo x) (pr XS L) (Bo' x) (pr XS' (L'' x))),
          close-term-ty L'' Ty L'.

        decompile-term-aux (prod Name Ty Bo) (pr XS L) (prod Name Ty Bo') (pr XS' L') :- !,
          (pi x\ locally-bound x => fold-map (Bo x) (pr XS L) (Bo' x) (pr XS' (L'' x))),
          close-term-ty L'' Ty L'.

        decompile-term-aux (app [T|L]) N R N :-
          name T,
          std.forall L locally-bound,
          distinct_names L,
          length L (s Len),
          var-mem T V Len Ty_, !,
          std.unsafe-cast V V',
          name R V' L.

        pred decompile-term i:list term, o:list term, i:term, o:term, o:list prop.
        decompile-term L L' T R Links :-
        (pi x y l1 l2\ fold-map x l1 y l2 :- decompile-term-aux x l1 y l2, !) =>
          fold-map T (pr L []) R (pr L' Links).

      }

      % Replaces univ and univ-instance rigid terms with uvars to help unification
      pred entry 
        i:term,               % the type of the instance
        i:term,               % the global gref of the instance
        i:list univ,          % the list of univ variable to be replaced with elpi fresh vars
        i:list univ-instance, % the list of univ-instance to be replaced with elpi fresh vars
        o:prop.               % the compiled clause for the instance

      entry Ty ProofHd [] [] Clause :-
        copy Ty Ty', !,
        tc.precomp.instance Ty' Ty'' N,
        add-pi-problematic-terms N [] Ty'' ProofHd Clause.
      entry Ty ProofHd [Univ | UnivL] UnivInstL (pi x\ Clause x) :- !,
        pi x\ (copy (sort (typ Univ)) (sort (typ x)) :- !) => 
          entry Ty ProofHd UnivL UnivInstL (Clause x).
      entry Ty ProofHd [] [UnivInst | UnivInstL] (pi x\ Clause x) :- !,
        pi x\ (copy (pglobal A UnivInst) (pglobal A x) :- !) => 
          entry Ty ProofHd [] UnivInstL (Clause x).

      pred clean-term i:term, o:term.
      clean-term A B :-
        (pi t s r\ copy (tc.maybe-eta-tm t s) r :- !, copy t r) =>
        (pi t s r\ copy (tc.maybe-beta-tm t s) r :- !, copy t r) =>
          copy A B.

      pred make-eta-link i:nat, i:term, i:term, i:term, i:name, i:list term, o:prop.
      make-eta-link z (tc.maybe-beta-tm (prod _ Ty _) _) A B Name L (link.eta A' (fun Name Ty' (x\ B' x))) :-
        clean-term Ty Ty',
        name A' A L,
        pi x\ sigma L'\ std.append L [x] L', name (B' x) B L'.
      make-eta-link (s N) (tc.maybe-beta-tm (prod _ Ty Bo) _) A B Name L (pi x\ decl x `x` Ty' => Link x) :-
        clean-term Ty Ty',
        pi x\ make-eta-link N (Bo x) A B Name [x|L] (Link x). 

      pred add-pi-problematic-terms
        i:nat,              % the number of pi to quantify
        i:list term,        % the list of quantified pi
        i:term,             % the fuel of the compilation (the type of the instance)
        i:term,             % the global gref of the current instance
        o:prop.             % the compiled clause for the instance

      add-pi-problematic-terms z L Ty ProofHd Clause :-
        compile-ty L _ ProofHd tt Ty [] [] Clause.
      add-pi-problematic-terms (s N) L Ty ProofHd (pi x\ Clause x) :-
        pi x\ is-uvar x => add-pi-problematic-terms N [x|L] Ty ProofHd (Clause x).


      % Add links as prem for map-dedup
      pred add-link-eta-dedup 
        i:(list prop -> prop -> prop),
        i:nat, i:nat, i:term, i:term, i:term, i:list prop, o:prop.
      add-link-eta-dedup F End End _ _ _ PremR Clause :- !, F PremR Clause.
      add-link-eta-dedup F N End OldVar P PTy PremR (pi x y\ Clause x y) :-
        pi x name\ sigma EtaLink\
          make-eta-link N PTy OldVar x name [] EtaLink,
          var-mem P x N PTy =>
            add-link-eta-dedup F (s N) End x P PTy [EtaLink | PremR] (Clause x name).

      pred compile-premise 
        i:list term,
        o:list term,
        i:term,
        i:term,
        i:term,
        i:bool,
        i:term,
        i:list term,
        i:list prop,
        o:prop.
      compile-premise L L2 P PTy ProofHd IsPositive ITy ProofTlR PremR Clause :-
        (pi a b c\ get-TC-of-inst-type (tc.maybe-beta-tm a c) b :- get-TC-of-inst-type a b) => 
          get-TC-of-inst-type PTy TC, !,
        compile-ty L L1 P {neg IsPositive} PTy [] [] NewPrem,
        if (class TC _ deterministic _)
          (NewPrem' = do-once NewPrem)
          (NewPrem' = NewPrem),
        compile-ty L1 L2 ProofHd IsPositive ITy ProofTlR [NewPrem' | PremR] Clause.
      compile-premise L L1 _ _ ProofHd IsPositive ITy ProofTlR PremR Clause :-
        compile-ty L L1 ProofHd IsPositive ITy ProofTlR PremR Clause. 

      pred compile-ty 
        i:list term,
        i:list term,
        i:term,
        i:bool,
        i:term,
        i:list term,
        i:list prop,
        o:prop.
      compile-ty L L1 ProofHd IsPositive (tc.maybe-beta-tm (prod N Ty Bo) Arity) ProofTlR PremR Clause :- !,
        std.do![
          if (IsPositive = tt) 
            (Clause = (pi x\ C x), E = x\[is-uvar x]) 
            (clean-term Ty Ty', Clause = (pi x\ decl x N Ty' => C x), E = x\[locally-bound x]),
          pi p\ sigma F\ 
            F = compile-premise L L1 p Ty ProofHd IsPositive (Bo p) [p|ProofTlR],
            E p => add-link-eta-dedup F z Arity p p Ty PremR (C p)
        ].
      compile-ty L L2 ProofHd IsPositive Goal ProofTlR PremR Clause :-
        std.do![    
          coq.mk-app ProofHd {std.rev ProofTlR} Proof,
          decompile.decompile-term L L1 Proof Proof' Prem1,
          decompile.decompile-term L1 L2 Goal Goal' Prem2,
          compile-conclusion IsPositive Goal' Proof' Prem2 Prem1 {std.rev PremR} Clause
        ].

      pred compile-conclusion 
        i:bool,             % tt if the term is in positive position
        i:term,             % the goal (invariant: it is a constant or a application)
        i:term,             % the proof
        i:list prop,        % the list of HOPremises in input mode
        i:list prop,        % the list of HOPremises in output mode
        i:list prop,        % the premises
        o:prop.             % the compiled clause for the instance

      compile-conclusion tt Goal Proof HOPremisesIn HOPremisesOut Premises Clause :-
        std.append {std.append HOPremisesIn Premises} HOPremisesOut AllPremises,
        make-tc Goal Proof AllPremises tt Clause.
      compile-conclusion ff Goal Proof HOPremisesIn HOPremisesOut Premises Clause :- 
        make-tc Goal Proof Premises ff Clause1, 
        std.append {std.append HOPremisesIn [Clause1]} HOPremisesOut AllPremises,
        Clause = do AllPremises.

      pred context i:goal-ctx, o:list prop.
      context [] [].
      context [X | Xs] [Clause | ResTl] :-
        (decl Var _ Ty = X; def Var _ Ty _ = X),
        is-instance-term Ty, !,
        compile.instance Ty Var Clause,
        context Xs ResTl.
      context [_ | Tl] L :- context Tl L.
    }

    % build a list of Clauses of type tc to be temporarly added to the 
    % database, used in theorems having assumptions.
    pred context i:goal-ctx, o:list prop.
    :name "tc-compile-context"
    context Ctx Clauses :-
      section-var->decl SectionVars,
      std.append Ctx SectionVars CtxAndSection,
      instance.context CtxAndSection Clauses. 

    % TODO: I don't link this implementation. 
    % I would prefer tc.precomp.instance to return N where N also includes the
    % number of get-univ and get-univ-instance. Then this N is used to build the
    % correct number of pi in Clause. Finally, while returning Clause, each 
    % sort (typ Univ) and (pglobal A x) is replaced with the right hole. This
    % reduce the complexity of fold: since the terms is folded in get-univ and
    % in tc.precomp.instance. It would be better to do this once in tc.precomp.instance.
    pred instance i:term, i:term, o:prop.
    instance Ty Proof Clause :-
      normalize-ty Ty Ty',
      tc.precomp.instance.get-univ Ty' UnivConstL,
      tc.precomp.instance.get-univ-instances Ty' UnivInstL,
      instance.entry Ty' Proof UnivConstL UnivInstL Clause.

    pred instance-gr i:gref, o:prop.
    instance-gr InstGR Clause :-
      coq.env.typeof InstGR Ty,
      tc.compile.instance Ty (global InstGR) Clause.
    
    namespace goal {
      % [uvar-pair V1 Ty V2] List of uvar for link-eta-dedup
      %                      V1 has arity n and V2 has arity n+1
      %                      If V1 has type A -> B, then A = Ty
      pred uvar-pair i:term, o:term, o:term.

      %                    Type     Var    Cnt    uvar-pair-list
      pred make-pairs-aux i:term, i:term, o:list prop.
      make-pairs-aux (prod _ Ty Bo) V [pi x\ uvar-pair x Ty X' :- x == V, ! | L] :- !,
        pi x\ make-pairs-aux (Bo x) X' L.
      make-pairs-aux Ty V [pi x\ uvar-pair x Ty V_ :- x == V, !].

      pred make-pairs i:list term, o:list prop.
      make-pairs [] [] :- !.
      make-pairs [X|Xs] L :- !,
        coq.typecheck X Ty ok,
        % std.assert! (not (var Ty)) "[TC] compile: Ty should not be flex", TODO: I want decomment this line once test.v passes
        make-pairs-aux Ty X L',
        make-pairs Xs L'',
        std.append L' L'' L.

      pred get-uva-pair-arity i:term, i:list term, o:term.
      get-uva-pair-arity X [] X :- !.
      get-uva-pair-arity X [_|L] Z :- uvar-pair X _ Y, !, 
        get-uva-pair-arity Y L Z.

      pred decompile-problematic-term i:term, i:list prop, o:term, o:list prop.
      decompile-problematic-term (tc.maybe-eta-tm T S) L V [link.eta V T' | L2] :-
        prune V S, !, fold-map T L T' L2.

      % TODO: maybe-llam
      % NOTE!!! a uvar in the goal has a scope!! At a certain point shoud do (X = uvar A S') and work with S'
      decompile-problematic-term (app[X|S]) L Z L :-
        var X, distinct_names S, !,
        get-uva-pair-arity X S Y,
        prune Z S, var Z Y S.

      pred compile i:term, i:list prop, o:term, o:list prop.
      compile T L T' L' :-
        (pi t l t' l'\ fold-map t l t' l' :- decompile-problematic-term t l t' l', !) =>
          fold-map T L T' L'.

      %                                  Uva      Binders      LinkEta 
      pred build-eta-links-of-vars-aux i:term, i:list term, o:list prop.
      build-eta-links-of-vars-aux Old L [Hd | Xs] :- 
        uvar-pair Old Ty Next, !,
        var OldScope Old L,
        Hd = link.eta OldScope (fun _ Ty (x\ NextScope x)),
        pi x\ sigma L'\
          std.append L [x] L',
          var (NextScope x) Next L',
          build-eta-links-of-vars-aux Next L' (Ys x), !,
        sigma Closed\ (close-term-no-prune-ty Ys Ty Closed),
        Xs = Closed.
      build-eta-links-of-vars-aux _ _ [].

      pred build-eta-links-of-vars i:list term, o:list prop.
      build-eta-links-of-vars [] [].
      build-eta-links-of-vars [V|Vars] L :-
        build-eta-links-of-vars-aux V [] L',
        build-eta-links-of-vars Vars L'',
        std.append L' L'' L.
    }
    
    %          Goal    Goal'      Links
    pred goal i:term, o:term, o:list prop.
    goal Goal Goal' Links :-
      tc.precomp.goal Goal GoalPrecomp Vars, !,
      goal.make-pairs Vars Pairs,
      Pairs => (
        goal.build-eta-links-of-vars Vars EtaLinks,
        goal.compile GoalPrecomp EtaLinks Goal' Links
      ).
  }
}