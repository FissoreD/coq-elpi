namespace old {

% HO unif heuristic: F X = f a b ~> F = f a, X = b
pred unify-FO o:list term, i:int, o:term, o:list term.
% (L, ArgsNo, Head) -> (Rigid, Flex, _)
unify-FO L ArgsNo Head Args :- var Head, not(var L), !, std.do! [
  std.length L Len,
  PrefixNo is Len - ArgsNo,
  PrefixNo > 0,
  split-at-not-fatal PrefixNo L [HD|Extra] Args,
  std.assert! (coq.mk-app HD Extra Head) "unif-FO error"
].
% (L, ArgsNo, Head) -> (Flex, Rigid, Rigid)
unify-FO L _ Head Args :- var L, not(var Head; var Args), !,
  coq.mk-app Head Args (app L).
% (L, ArgsNo, Head) -> (Rigid, Rigid, Rigid)
unify-FO L ArgsNo_ Head Args :-
  not (var L; var Head; var Args), !,
  coq.mk-app Head Args (app L).
unify-FO L _ H A :- var L, var H, !, L = [H|A].
unify-FO L _ H A :- coq.error "unif-FO mess" L H A.

pred locally-bound o:term.

pred build-fun i:term, i:A, o:term.
build-fun (prod N T Bo) V (fun N T Bo1) :- 
  is-coq-term V, !,
  pi x\ build-fun (Bo x) {coq.mk-app V [x]} (Bo1 x).
build-fun (prod N T Bo) V (fun N T Bo1) :- !,
  pi x\ build-fun (Bo x) (V x) (Bo1 x).
build-fun _ V V.

pred coq.reduction.eta-expand i:int, i:term, i:list term, o:A.
coq.reduction.eta-expand 0 P L X :- std.rev L L1, hd-beta P L1 Hd Args, coq.mk-app Hd Args X.
coq.reduction.eta-expand N P Acc (x\ Q x) :- N > 0, M is N - 1,
  pi x\ coq.reduction.eta-expand M P [x|Acc] (Q x).

pred ho-link o:term, i:term, o:A.
:name "ho-link"
% (C, E) -> (Rigid, Flex)
ho-link C Ty E :- var E, not (var C), !, 
  coq.count-prods Ty N, coq.reduction.eta-expand N C [] E.
% (C, E) -> (Flex, Rigid)
ho-link C Ty E :- var C, not (var E), !, 
  build-fun Ty E ETA, coq.reduction.eta-contract ETA C.
% (C, E) -> (Rigid, Rigid)
ho-link C Ty E :- not (var C), not (var E), !, same-eta C Ty [] E.
% (C, E) -> (Flex, Flex)
ho-link _C _Ty _E.

pred same-eta i:term, i:term, i:list term, i:A.
:name "same-eta1"
same-eta C (prod _ _ F) V E :- !, pi x\ same-eta C (F x) [x|V] (E x).
:name "same-eta2"
same-eta C _ VarsRev E :-
  coq.mk-app C {std.rev VarsRev} CVars,
  hd-beta E [] Hd Args, coq.mk-app Hd Args EVars,
  std.assert! (CVars = EVars) "eta mess".

pred coq-intros i:list term, i:list term, i:list term, o:term, o:A.
coq-intros SC [] V K K :-
  std.append SC {std.rev V} L, prune K L.
coq-intros SC [HD|L] LL (fun `elpi_intro` Ty Bo) E :-
  coq.typecheck HD Ty ok,
  pi x\ coq-intros SC L [x | LL] (Bo x) (E x).

pred apply-local-vars i:A, i:list term, o:B.
apply-local-vars T [] T.
apply-local-vars T [A | TL] X :-
  apply-local-vars (T A) TL X.

pred under-prod o:term.

pred subst-ho i:term, i:list prop, o:term, o:list prop.
% pattern fragment 
subst-ho (app [ho-var X Pos|XS]) A YXS A1 :- 
  name X, ho-twin X Pos Y _ Ty, distinct_names XS, std.forall XS locally-bound, !,
  name YXS Y XS,
  std.unsafe-cast Y Y1,
  A1 = [ho-link X Ty Y1|A].
subst-ho X A X A :- var X, !.
subst-ho (app [X|XArgs]) A R A1 :- std.do![
  var X _ XScope,
  std.append XScope XArgs Scope,
  distinct_names Scope, !,
  coq-intros XScope XArgs [] X' E,
  hd-beta X' XArgs Aaa Baa,
  coq.mk-app Aaa Baa R,
  coq.typecheck X Ty ok,
  A1 = [ ho-link X Ty E | A]].
subst-ho (ho-var X Pos) A X A1 :- name X, ho-twin X Pos Y _ Ty, !, A1 = [ho-link X Ty Y|A].
:name "FO heuristic"
subst-ho (app [ho-var X Pos|XS]) A (app L') A2 :- name X, ho-twin X Pos Y_ L Ty_, !,
  std.findall-unary under-prod LocVars,
  apply-local-vars L {std.rev LocVars} L',
  % L = L',
  std.length XS NARGS,
  std.fold-map XS A fold-map YS A1,
  A2 = [unify-FO L' NARGS X YS , /* ho-link X Ty_ Y_ */ |A1].
% A2 = [unify-FO L' NARGS X YS|A1].
% mark local binders
% subst-ho (prod N T F) A (prod N T1 F1) A2 :- !,
%   fold-map T A T1 A1, (pi x\ locally-bound x => fold-map (F x) A1 (F1 x) A2).
% subst-ho (fun N T F) A (fun N T1 F1) A2 :- !,
%   fold-map T A T1 A1, (pi x\ locally-bound x => fold-map (F x) A1 (F1 x) A2).
subst-ho (prod N T F) A (prod N T1 F1) [@pi-decl N T x\ A2 x] :- !, 
  fold-map T A T1 A1, !, (@pi-decl N T x\ locally-bound x => under-prod x => fold-map (F x) A1 (F1 x) (R x)), 
  A2 = (x\ (do (R x))).
subst-ho (fun N T F) A (fun N T1 F1) [@pi-decl N T x\ A2 x] :- !, 
  fold-map T A T1 A1, !, (@pi-decl N T x\ locally-bound x => under-prod x => fold-map (F x) A1 (F1 x) (R x)), 
  A2 = (x\ (do (R x))).
subst-ho (ho-var A _) L A L :- !.


pred ho-preprocess i:term, o:term, o:list prop.
ho-preprocess Ty TyX HOPremises :-
  (pi A B C D\ fold-map A B C D :- subst-ho A B C D, !) =>
    fold-map Ty [] TyX HOPremisesRev,
  std.rev HOPremisesRev HOPremises.
% ho-preprocess Ty TyX HOPremises :-
%   coq.error "ho-preprocess failure with" Ty TyX HOPremises.

pred ho-cleanup i:term, o:term.
ho-cleanup T T1 :- (pi X\ copy (ho-var X _) X :- !) => copy T T1.

% [ho-twin Coq ElpiHO ElpiFO CoqVarTy]
% app[Coq|Args] -> (app ElpiFO)    / unif-FO ElpiFO N Coq Args
% app[Coq|Args] -> (ElpiHO Args)   / ho-link Coq CoqVarTy ElpiHO
pred ho-twin i:term, o:int, o:A, o:list B, o:term.
ho-twin X I_ Y_ Z_ Ty :- var X, !, 
  coq.typecheck X Ty ok.

type ho-var term -> int -> term.

pred count-occurrences i:term, i:term, o:term, o:int.
count-occurrences T V T1 N :-
  (pi A A1\ fold-map V A (ho-var V A) A1 :- !, A1 is A + 1) =>
  (pi A B\ fold-map A B A B :- A = ho-var _ _, !) =>
  fold-map T 0 T1 N, !.
}

kind nat type.
type z nat.
type s nat -> nat.

pred count-prod i:term , o:nat.
count-prod (prod _ _ B) (s N) :- !, pi x\ count-prod (B x) N.
count-prod _ z.

pred length i:list A, o:nat.
length [] z.
length [_|L] (s N) :- length L N.

% [var-mem F Ar H Ty]
% we associate the FO variable F, to the HO variable H 
% with airty Ar and type Ty
pred var-mem o:term, o:any, o:nat, o:term.

pred locally-bound o:term.

% pred ho-compile-type 

% TODO: need to also return link, for the moment only compile ho-vars
pred fo-to-ho-aux i:term, o:term. %, o:list prop.
fo-to-ho-aux (app [T|L]) R :-
  std.forall L locally-bound,
  distinct_names L,
  var-mem T V {length L} Ty_, !,
  std.unsafe-cast V V',
  name R V' L.

pred fo-to-ho i:term, o:term, o:list prop.
fo-to-ho T T1 [] :-
  (pi x y\ copy x y :- fo-to-ho-aux x y, !) => copy T T1.
