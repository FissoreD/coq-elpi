namespace tc {

  namespace precomp {

    namespace instance {
      % Tells if the current name is a bound variables
      pred is-name o:term.
      % Tells if the current name stands for a uvar
      pred is-uvar o:term.

      pred maybe-eta-aux-compilation1 i:term, i:list term.
      maybe-eta-aux-compilation1 (app [H|S]) L :- is-uvar H, !, 
        std.forall L (x\ exists! S (y\ link.may-contract-to [] x y)).

      pred may-contract-to-aux-compilation1 i:list term, i:term, i:term.
      may-contract-to-aux-compilation1 L N (app [H|S]) :- is-uvar H, !, 
        std.forall [N|L] (x\ exists! S (y\ link.may-contract-to [] x y)).

      % pred is-maybe-llam i:list term, i:list term, o:list term, o:list term.
      % is-maybe-llam [] _ _ _ :- !, fail.
      % is-maybe-llam [X|L] PF [X|XS] NPF :-
      %   is-name X, not (std.mem! PF X), !, 
      %   is-maybe-llam L [X|PF] XS NPF.
      % is-maybe-llam L PF PF L.

      pred free-var o:list term.
      free-var L :-
        std.findall (is-name _) T,
        std.map T (x\y\ x = is-name y) L.

      pred precompile-aux i:bool, i:term, i:A, o:term, o:A.
      precompile-aux _ X A Y A :- name X, !, X = Y, !. % avoid loading "precompile-aux x A x A" at binders
      precompile-aux _ (global _ as C) A C A :- !.
      precompile-aux _ (pglobal _ _ as C) A C A :- !.
      precompile-aux _ (sort _ as C) A C A :- !.

      % Detect maybe-eta term
      precompile-aux IsP (fun Name Ty B) N (tc.maybe-eta-tm (fun Name Ty B') Scope) (s M) :-
        % free-var (fun Name Ty B) Scope,
        free-var Scope,
        (pi T L\ link.maybe-eta-aux T L :- maybe-eta-aux-compilation1 T L, !) => 
        (pi L N T\ link.may-contract-to L N T :- may-contract-to-aux-compilation1 L N T) =>
          (pi x\ link.maybe-eta-aux (B x) [x]), !,
        (pi x\ is-name x => precompile-aux IsP (B x) N (B' x) M).

      % Detect maybe-llam term
      % TODO: detect maybe-llam
      % precompile-aux IsP (app [X|XS]) N (tc.maybe-llam-tm X PF NPF1 Scope) (s M) :- fail,
      %   is-uvar X,
      %   is-maybe-llam XS [] PF NPF, !,
      %   free-var Scope,
      %   std.fold-map NPF N (precompile-aux IsP) NPF1 M. 

      % Charge if we work with unification variable or local name
      % And returns the subterms is a maybe-beta-tm
      precompile-aux IsP (prod Name Ty B) N (tc.maybe-beta-tm (prod Name Ty' B') MaxAr) P :- !,
        % std.assert! (pi x\ count-maximal-arity x (B x) MaxAr) "[TC] count-maximal-arity should not fail",
        count-prod Ty MaxAr,
        if (IsP = tt) (C = x\ is-uvar x) (C = x\ is-name x),
        std.assert! (pi x\ C x => precompile-aux IsP (B x) N (B' x) M) "[TC] should not fail",
        precompile-aux {neg IsP} Ty M Ty' P.

      % Working with fun
      precompile-aux IsP (fun N T F) A (fun N T F1) A2 :- !, A = A1,
        /*precompile-aux IsP T A T1 A1,*/ pi x\ is-name x => precompile-aux IsP (F x) A1 (F1 x) A2.
      
      precompile-aux IsP (app L) A (app L1) A1 :- !, std.fold-map L A (precompile-aux IsP) L1 A1.

      % TODO: what about the following constructors?
      % precompile-aux IsP (let N T B F) A (let N T1 B1 F1) A3 :- !,
      %   precompile-aux IsP T A T1 A1, precompile-aux IsP B A1 B1 A2, pi x\ is-name x => precompile-aux IsP (F x) A2 (F1 x) A3.
      % precompile-aux IsP (fix N Rno Ty F) A (fix N Rno Ty1 F1) A2 :- !,
      %   precompile-aux IsP Ty A Ty1 A1, pi x\ is-name x => precompile-aux IsP (F x) A1 (F1 x) A2.
      % precompile-aux IsP (match T Rty B) A (match T1 Rty1 B1) A3 :- !,
      %   precompile-aux IsP T A T1 A1, precompile-aux IsP Rty A1 Rty1 A2, std.fold-map B A2 (precompile-aux IsP) B1 A3.
      % precompile-aux _ (primitive _ as C) A C A :- !.
      % precompile-aux IsP (uvar M L as X) A W A1 :- var X, !, std.fold-map L A (precompile-aux IsP) L1 A1, coq.mk-app-uvar M L1 W.
      % % when used in CHR rules
      % precompile-aux IsP (uvar X L) A (uvar X L1) A1 :- std.fold-map L A (precompile-aux IsP) L1 A1.
    }

    namespace goal {

      pred precompile-aux i:term, i:list term, o:term, o:list term.
      precompile-aux X A Y A :- name X, !, X = Y, !. % avoid loading "precompile-aux x A x A" at binders
      precompile-aux (global _ as C) A C A :- !.
      precompile-aux (pglobal _ _ as C) A C A :- !.
      precompile-aux (sort _ as C) A C A :- !.

      pred maybe-eta-aux1 i:term, i:list term.
      maybe-eta-aux1 (app [X|S]) L :- 
        var X, !, std.forall L (std.mem! S).

      pred may-contract-to1 i:list term, i:term, i:term.
      may-contract-to1 L N (app [X|S]) :- var X, !, std.forall [N|L] (std.mem! S).

      % Detect maybe-eta term
      precompile-aux (fun Name Ty B) N (tc.maybe-eta-tm (fun Name Ty B') Scope) M :-
        names Scope,
        (pi x y\ link.maybe-eta-aux x y :- maybe-eta-aux1 x y, !) =>
        (pi x y z\ link.may-contract-to x y z :- may-contract-to1 x y z, !) =>
        pi x\ link.maybe-eta-aux (B x) [x], !,
        (pi x\ precompile-aux (B x) N (B' x) M).

      % Charge if we work with unification variable or local name
      % And returns the subterms is a maybe-beta-tm
      precompile-aux (prod Name Ty B) N (tc.maybe-beta-tm (prod Name Ty' B') MaxAr) P :- !,
        count-prod Ty MaxAr,
        std.assert! (pi x\ precompile-aux (B x) N (B' x) M) "[TC] should not fail",
        precompile-aux Ty M Ty' P.

      % Working with fun
      precompile-aux (fun N T F) A (fun N T F1) A2 :- !, A = A1,
        /*precompile-aux IsP T A T1 A1,*/ pi x\ precompile-aux (F x) A1 (F1 x) A2.
      
      precompile-aux (app L) A (app L1) A1 :- !, std.fold-map L A precompile-aux L1 A1.
      precompile-aux (let N T B F) A (let N T1 B1 F1) A3 :- !,
        precompile-aux T A T1 A1, precompile-aux B A1 B1 A2, pi x\ precompile-aux (F x) A2 (F1 x) A3.
      precompile-aux (fix N Rno Ty F) A (fix N Rno Ty1 F1) A2 :- !,
        precompile-aux Ty A Ty1 A1, pi x\ precompile-aux (F x) A1 (F1 x) A2.
      precompile-aux (match T Rty B) A (match T1 Rty1 B1) A3 :- !,
        precompile-aux T A T1 A1, precompile-aux Rty A1 Rty1 A2, std.fold-map B A2 precompile-aux B1 A3.
      precompile-aux (primitive _ as C) A C A :- !.
      precompile-aux X A X [X|A] :- var X, !.
    }

    % [tc.precomp.instance T T' N] 
    /*
      Returns T' N from T, where: 
        T' is obtained by the replacement of
          - all maybe-eta term `t1` with (tc.maybe-eta-tm `t1` `s`) where `s` = FV(`t1`)
              ==> This helps knowing if a subterm should be replaced with a `eta-link`
          - all `prod _ Ty (x\ Bo x)` with (tc.maybe-beta-tm (prod _ Ty (x\ Bo x)) N), 
            where N is the number of prod in Ty
            TODO: it is better to only charge the `right` number of link-eta, that is the maximal 
                  application of each uvars
                  for example:
                    prod _ (Type -> Type -> Type -> Type -> Type) (x\ c1 (x nat bool) (x nat) (x nat nat bool)).
                  is replace with
                    (tc.maybe-beta-tm (prod _ (Type -> Type -> Type -> Type -> Type) (x\ c1 (x nat)) 3)
                  since x is applied at most 3 times in the original term
                    ==> This helps charging the right number of `eta-link` for map-deduplication rule
        N is the number of problematic terms in T
    */
    pred instance i:term, o:term, o:nat.
    instance T T' N :- instance.precompile-aux tt T z T' N.

    pred goal i:term, o:term, o:list term.
    goal T T' Vars' :- goal.precompile-aux T [] T' Vars, undup-same Vars Vars'. 
  }
}