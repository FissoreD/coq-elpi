namespace tc {
  namespace link {
    pred eta-expand i:term, o:term.  
    eta-expand T1 (fun _ _ B) :- (name T1; is-coq-term T1), !, pi x\ coq.mk-app T1 [x] (B x). 
    eta-expand T1 (fun _ _ R) :- pi x\ name (R x) T1 [x].

    :index (_ _ 1)
    pred may-contract-to i:list term, i:term, i:term.
    may-contract-to _ N N :- name N, !.
    may-contract-to L N V :- var V _ S, !,
        std.forall [N|L] (x\ exists! S (may-contract-to [] x)).
    may-contract-to L N (app [N|A]) :-
      std.length A {std.length L},
      std.forall2 {std.rev L} A (may-contract-to []).
    may-contract-to L N (fun _ _ B) :-
      pi x\ may-contract-to [x|L] N (B x).

    pred occurs-rigidly i:term, i:term.
    occurs-rigidly N N :- name N, !.
    occurs-rigidly _ V :- var V, !, fail.
    occurs-rigidly N (app A) :- exists! A (occurs-rigidly N).
    occurs-rigidly N (fun _ _ B) :- pi x\ occurs-rigidly N (B x).

    pred maybe-eta-aux i:term, i:list term.
    maybe-eta-aux V L :- var V _ S, std.forall L (std.mem! S).
    maybe-eta-aux (app [_|A]) L :-
      SplitLen is {std.length A} - {std.length L},
      split-at-not-fatal SplitLen A HD TL,
      std.forall L (x\ not (exists! HD (occurs-rigidly x))),
      std.forall2 {std.rev L} TL (may-contract-to []). 
    maybe-eta-aux (fun _ _ B) L :-
      pi x\ maybe-eta-aux (B x) [x|L].

    pred maybe-eta i:term.
    maybe-eta (fun _ _ B) :- pi x\ maybe-eta-aux (B x) [x].

    pred unify-left-right i:term, i:term.
    unify-left-right (fun _ _ A) (fun _ _ A') :- !, pi x\ unify-left-right (A x) (A' x).
    unify-left-right A (fun _ _ _ as T) :- !, eta-expand A Ae, pi x\ unify-left-right Ae T.
    unify-left-right A A' :- A = A'.

    pred progress-eta-left i:term, o:term.
    progress-eta-left A _ :- var A, !, fail.
    progress-eta-left (fun _ _ A) (fun _ _ B) :- var B, !, A = B.
    progress-eta-left A A' :- (name A; is-coq-term A), !, eta-expand A A'.

    pred progress-eta-right i:term, o:term.
    progress-eta-right A A' :- coq.reduction.eta-contract A A', not (A = A'), !.
    progress-eta-right A A :- not (maybe-eta A), !.

    pred scope-check i:term, i:term.
    scope-check (uvar _ L) T :- prune A L, A = T, !.

    pred get-vars i:term, o:list term.
    get-vars T R :-
      (pi X H L Ign\ fold-map X L X [H|L] :- var X H Ign, !) => 
        fold-map T [] _ R.

    pred relocate i:list term, i:list term, i:term, o:term.
    relocate [] [] T T' :- copy T T', coq.say "Copy result is" T T'.
    relocate [X|Xs] [Y|Ys] T T' :-
      coq.say "Charging" (copy Y X),
      (copy Y X :- !) => relocate Xs Ys T T'.

    % constraint eta uvar relocate fun {
    %   rule (N1 : G1 ?- eta (uvar X L1) (fun _ T1 B1)) 
    %       \ (N2 : G2 ?- eta (uvar X L2) (fun _ T2 B2)) 
    %       | (
    %         pi x\ relocate L1 L2 (B2 x) (B2' x),
    %         coq.say "Will unify" B1 "and" B2'
    %       )  
    %   <=> (N1 : G1 ?- B1 = B2').
    % }

    pred collect-store o:list prop.
    pred collect-store-aux i:list prop, o:list prop.

    collect-store L :- collect-store-aux [] L.
    collect-store-aux X L :- declare_constraint (collect-store-aux X L) [_].

    pred solve-eta.
    solve-eta :- declare_constraint solve-eta [_].

    pred unify-eta i:term, i:term.
    % unify-eta A B :- coq.say "Unify-eta" "A"A"B"B, fail.
    unify-eta A B :- var A, !, A = B, !.
    unify-eta (fun _ _ A) (fun _ _ B) :- !, pi x\ unify-eta (A x) (B x).
    unify-eta A (fun _ _ _ as B) :- !, eta-expand A A', unify-eta A' B.
    unify-eta A B :- A = B.

    constraint eta uvar relocate fun collect-store-aux solve-eta {
      rule solve-eta \ (eta A B) <=> (unify-eta A B).
      rule \ solve-eta.
      % rule (N1 : G1 ?- eta (uvar X L1) (fun _ T1 B1)) 
      %     \ (N2 : G2 ?- eta (uvar X L2) (fun _ T2 B2)) 
      %     | (
      %       pi x\ relocate L2 L1 (B1 x) (B1' x)
      %     )  
      % <=> (N2 : G2 ?- B2 = B1').

      % TODO: link collect do not work since it closes links and 
      %       therefore variables are prune
      % rule \ (tc.link.eta A B) (collect-store-aux L R) | (coq.say A B {names}) <=> (collect-store-aux [tc.link.eta A B|L] R).
      % rule \ (collect-store-aux L R) <=> (R = L).
    }

    pred eta i:term, i:term.
    eta _ B :- var B, coq.error "[TC] link.eta error, flexible rhs".
    % TODO: Next rule is for goals of the form `link.eta {{f}} {{fun x y => f x y}}`
    %       Is it possible to have `link.eta {{f}} {{fun x y => lp:(X y x)}}` ?
    %       if so, this breaks eta progression
    eta A (fun _ _ B as T) :- not (var A), not (var B), !, unify-left-right A T. 
    eta A B :- progress-eta-right B B', !, A = B'. 
    eta A B :- progress-eta-left A A', !, A' = B.
    eta A B :- scope-check A B, get-vars B Vars, declare_constraint (eta A B) [_,A|Vars].

    %                            Scope        Var     Args       Rhs
    pred progress-llam-refine i:list term, i:term, i:list term, o:term.
    progress-llam-refine S V [A|As] R :- name A, not (std.mem! S A), !,
      % prune (V' A) [A|S],
      eta V (fun _ _ (x\ V' x)),
      progress-llam-refine [A|S] (V' A) As R.
    progress-llam-refine _ V [] V.
    progress-llam-refine _ V As (app [V|As]).

    pred split-pf i:list term, i:list term, o:list term, o:list term.
    split-pf [] _ [] [] :- !.
    split-pf [X|Xs] Old [X|Ys] L :- name X, not (std.mem! Old X), !, split-pf Xs [X|Old] Ys L.
    split-pf Xs _ [] Xs.

    pred lam->fun i:term, i:list term, i:any.
    lam->fun T [] R :- !, std.unsafe-cast R R', copy T T', R' = T'.
    lam->fun Hd [H|L] R :- !,
      pi x\ (copy H x :- !) => lam->fun Hd L (R' x),
      std.unsafe-cast R Rx, Rx = R'.

    pred unify-align i:term, i:term, i:list term, i:list term.
    unify-align (app L) Hd PF NPF :-
      Len is {std.length L} - {std.length NPF}, Len >= 0,
      std.split-at Len L L' NPF,
      Z = app L',
      coq.mk-app Z NPF TT,
      lam->fun TT {std.append PF NPF} Hd.

    pred unify-const i:term, i:term, i:list term.
    unify-const N R [] :- !, copy N X, R = X.
    unify-const N R [A|As] :- not found.aux, A == N, !,
      pi x\ found.aux => (copy N x :- !) => unify-const N (R' x) As,
      std.unsafe-cast R Rx, Rx = R'.
    unify-const N R [_|As] :- 
      pi x\ unify-const N (R' x) As,
      std.unsafe-cast R Rx, Rx = R'.

    pred unify-heuristics i:term, i:term.
    % unify-heuristics A T :- coq.say "A"A "B"T, fail.
    unify-heuristics (app _ as A) (fun _ _ B) :- !,
      eta-expand A (fun _ _ A'), pi x\ unify-heuristics (A' x) (B x).
    unify-heuristics (app _ as A) B :- var B Hd Tl, !,
      split-pf Tl [] PF NPF, 
      unify-align A Hd PF NPF.
    unify-heuristics A B :- name A, var B Hd Tl, !, % TODO: also const
      unify-const A Hd Tl.
    unify-heuristics (app L) (app L') :-
      std.forall2 L L' unify-heuristics. 
    unify-heuristics A B :- A = B.

    pred llam-aux i:term, i:term.
    llam-aux A T :- var T, !, A = T. % Here, both A and T are in PF
    llam-aux A (app [H|L] as T) :- var A, var H, !, get-vars T Vars, declare_constraint (llam A (app [H|L])) [_,A|Vars].
    llam-aux A (app [H|L] as T) :- var H, !, get-vars T Vars, declare_constraint (llam A (app [H|L])) [_|Vars].
    llam-aux A (app [H|L]) :- coq.mk-app H L T, !, unify-heuristics A T.

    pred llam i:term, i:term.
    llam L (app [H|As]) :- var H _ S, !,
      progress-llam-refine S H As Rhs,
      llam-aux L Rhs.
    llam L Rhs :- llam-aux L Rhs.
  }
}