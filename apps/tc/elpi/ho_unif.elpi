namespace old {

% HO unif heuristic: F X = f a b ~> F = f a, X = b
pred unify-FO o:list term, i:int, o:term, o:list term.
% (L, ArgsNo, Head) -> (Rigid, Flex, _)
unify-FO L ArgsNo Head Args :- var Head, not(var L), !, std.do! [
  std.length L Len,
  PrefixNo is Len - ArgsNo,
  PrefixNo > 0,
  split-at-not-fatal PrefixNo L [HD|Extra] Args,
  std.assert! (coq.mk-app HD Extra Head) "unif-FO error"
].
% (L, ArgsNo, Head) -> (Flex, Rigid, Rigid)
unify-FO L _ Head Args :- var L, not(var Head; var Args), !,
  coq.mk-app Head Args (app L).
% (L, ArgsNo, Head) -> (Rigid, Rigid, Rigid)
unify-FO L ArgsNo_ Head Args :-
  not (var L; var Head; var Args), !,
  coq.mk-app Head Args (app L).
unify-FO L _ H A :- var L, var H, !, L = [H|A].
unify-FO L _ H A :- coq.error "unif-FO mess" L H A.

pred locally-bound o:term.

pred build-fun i:term, i:A, o:term.
build-fun (prod N T Bo) V (fun N T Bo1) :- 
  is-coq-term V, !,
  pi x\ build-fun (Bo x) {coq.mk-app V [x]} (Bo1 x).
build-fun (prod N T Bo) V (fun N T Bo1) :- !,
  pi x\ build-fun (Bo x) (V x) (Bo1 x).
build-fun _ V V.

pred coq.reduction.eta-expand i:int, i:term, i:list term, o:A.
coq.reduction.eta-expand 0 P L X :- std.rev L L1, hd-beta P L1 Hd Args, coq.mk-app Hd Args X.
coq.reduction.eta-expand N P Acc (x\ Q x) :- N > 0, M is N - 1,
  pi x\ coq.reduction.eta-expand M P [x|Acc] (Q x).

pred ho-link o:term, i:term, o:A.
:name "ho-link"
% (C, E) -> (Rigid, Flex)
ho-link C Ty E :- var E, not (var C), !, 
  coq.count-prods Ty N, coq.reduction.eta-expand N C [] E.
% (C, E) -> (Flex, Rigid)
ho-link C Ty E :- var C, not (var E), !, 
  build-fun Ty E ETA, coq.reduction.eta-contract ETA C.
% (C, E) -> (Rigid, Rigid)
ho-link C Ty E :- not (var C), not (var E), !, same-eta C Ty [] E.
% (C, E) -> (Flex, Flex)
ho-link _C _Ty _E.

pred same-eta i:term, i:term, i:list term, i:A.
:name "same-eta1"
same-eta C (prod _ _ F) V E :- !, pi x\ same-eta C (F x) [x|V] (E x).
:name "same-eta2"
same-eta C _ VarsRev E :-
  coq.mk-app C {std.rev VarsRev} CVars,
  hd-beta E [] Hd Args, coq.mk-app Hd Args EVars,
  std.assert! (CVars = EVars) "eta mess".

pred coq-intros i:list term, i:list term, i:list term, o:term, o:A.
coq-intros SC [] V K K :-
  std.append SC {std.rev V} L, prune K L.
coq-intros SC [HD|L] LL (fun `elpi_intro` Ty Bo) E :-
  coq.typecheck HD Ty ok,
  pi x\ coq-intros SC L [x | LL] (Bo x) (E x).

pred apply-local-vars i:A, i:list term, o:B.
apply-local-vars T [] T.
apply-local-vars T [A | TL] X :-
  apply-local-vars (T A) TL X.

pred under-prod o:term.

pred subst-ho i:term, i:list prop, o:term, o:list prop.
% pattern fragment 
subst-ho (app [ho-var X Pos|XS]) A YXS A1 :- 
  name X, ho-twin X Pos Y _ Ty, distinct_names XS, std.forall XS locally-bound, !,
  name YXS Y XS,
  std.unsafe-cast Y Y1,
  A1 = [ho-link X Ty Y1|A].
subst-ho X A X A :- var X, !.
subst-ho (app [X|XArgs]) A R A1 :- std.do![
  var X _ XScope,
  std.append XScope XArgs Scope,
  distinct_names Scope, !,
  coq-intros XScope XArgs [] X' E,
  hd-beta X' XArgs Aaa Baa,
  coq.mk-app Aaa Baa R,
  coq.typecheck X Ty ok,
  A1 = [ ho-link X Ty E | A]].
subst-ho (ho-var X Pos) A X A1 :- name X, ho-twin X Pos Y _ Ty, !, A1 = [ho-link X Ty Y|A].
:name "FO heuristic"
subst-ho (app [ho-var X Pos|XS]) A (app L') A2 :- name X, ho-twin X Pos Y_ L Ty_, !,
  std.findall-unary under-prod LocVars,
  apply-local-vars L {std.rev LocVars} L',
  % L = L',
  std.length XS NARGS,
  std.fold-map XS A fold-map YS A1,
  A2 = [unify-FO L' NARGS X YS , /* ho-link X Ty_ Y_ */ |A1].
% A2 = [unify-FO L' NARGS X YS|A1].
% mark local binders
% subst-ho (prod N T F) A (prod N T1 F1) A2 :- !,
%   fold-map T A T1 A1, (pi x\ locally-bound x => fold-map (F x) A1 (F1 x) A2).
% subst-ho (fun N T F) A (fun N T1 F1) A2 :- !,
%   fold-map T A T1 A1, (pi x\ locally-bound x => fold-map (F x) A1 (F1 x) A2).
subst-ho (prod N T F) A (prod N T1 F1) [@pi-decl N T x\ A2 x] :- !, 
  fold-map T A T1 A1, !, (@pi-decl N T x\ locally-bound x => under-prod x => fold-map (F x) A1 (F1 x) (R x)), 
  A2 = (x\ (do (R x))).
subst-ho (fun N T F) A (fun N T1 F1) [@pi-decl N T x\ A2 x] :- !, 
  fold-map T A T1 A1, !, (@pi-decl N T x\ locally-bound x => under-prod x => fold-map (F x) A1 (F1 x) (R x)), 
  A2 = (x\ (do (R x))).
subst-ho (ho-var A _) L A L :- !.


pred ho-preprocess i:term, o:term, o:list prop.
ho-preprocess Ty TyX HOPremises :-
  (pi A B C D\ fold-map A B C D :- subst-ho A B C D, !) =>
    fold-map Ty [] TyX HOPremisesRev,
  std.rev HOPremisesRev HOPremises.
% ho-preprocess Ty TyX HOPremises :-
%   coq.error "ho-preprocess failure with" Ty TyX HOPremises.

pred ho-cleanup i:term, o:term.
ho-cleanup T T1 :- (pi X\ copy (ho-var X _) X :- !) => copy T T1.

% [ho-twin Coq ElpiHO ElpiFO CoqVarTy]
% app[Coq|Args] -> (app ElpiFO)    / unif-FO ElpiFO N Coq Args
% app[Coq|Args] -> (ElpiHO Args)   / ho-link Coq CoqVarTy ElpiHO
pred ho-twin i:term, o:int, o:A, o:list B, o:term.
ho-twin X I_ Y_ Z_ Ty :- var X, !, 
  coq.typecheck X Ty ok.

type ho-var term -> int -> term.

pred count-occurrences i:term, i:term, o:term, o:int.
count-occurrences T V T1 N :-
  (pi A A1\ fold-map V A (ho-var V A) A1 :- !, A1 is A + 1) =>
  (pi A B\ fold-map A B A B :- A = ho-var _ _, !) =>
  fold-map T 0 T1 N, !.
}

namespace link {
  pred eta-expand i:term, i:term, o:term.  
  eta-expand T1 Ty (fun _ Ty B) :- is-coq-term T1, !,
    pi x\ coq.mk-app T1 [x] (C x), fo-to-ho (C x) (B x) _. 
  eta-expand T1 Ty (fun _ Ty R) :-
    pi x\ std.spy(name (R x) T1 [x]).

  pred unify-under-fun i:any, i:term.
  unify-under-fun A (fun _ _ B) :- !,
    std.unsafe-cast A A', pi x\ unify-under-fun (A' x) (B x).
  unify-under-fun A B :- A = B.
  
  pred progress-eta-left i:term, o:term.
  progress-eta-left A _ :- var A, !, fail.
  progress-eta-left (fun _ _ A) (fun _ _ A) :- !.
  progress-eta-left A A' :- is-coq-term A, !, eta-expand A _ A'.
  progress-eta-left A (fun _ Ty_ B) :- !, std.unsafe-cast A B. % A is elpi lambda, (x\ _)

  :index (_ _ 1)
  pred may-contract-to i:list term, i:term, i:term.
  may-contract-to _ N N :- !.
  may-contract-to L N V :- var V _ S, !, std.forall [N|L] (std.mem! S).
  may-contract-to L N (app [N|A]) :-
    std.length A {std.length L},
    std.forall2 A {std.rev L} (may-contract-to []).
  may-contract-to L N (fun _ _ B) :-
    pi x\ may-contract-to [x|L] N (B x).

  pred occurs-rigidly i:term, i:term.
  occurs-rigidly N N.
  occurs-rigidly N (app A) :- exists! A (occurs-rigidly N).
  occurs-rigidly N (fun _ _ B) :- pi x\ occurs-rigidly N (B x).

  pred maybe-eta-aux i:term, i:list term.
  maybe-eta-aux V L :- var V _ S, std.forall L (std.mem! S).
  maybe-eta-aux (app [_|A]) L :-
    SplitLen is {std.length L} - {std.length A},
    split-at-not-fatal SplitLen A HD TL,
    std.forall L (x\ not (exists! HD (occurs-rigidly x))),
    std.forall2 TL {std.rev L} (may-contract-to []). 
  maybe-eta-aux (fun _ _ B) L :-
    pi x\ maybe-eta-aux (B x) [x|L].

  pred maybe-eta i:term.
  maybe-eta (fun _ _ B) :- pi x\ maybe-eta-aux (B x) [x].

  pred progress-eta-right i:term, o:term.
  progress-eta-right A A :- not (maybe-eta A), !.
  progress-eta-right A A' :- coq.reduction.eta-contract A A', not (A = A'), !.

  pred get-vars i:term, o:list term.
  get-vars T R :-
    (pi X H L Ign\ fold-map X L X [H|L] :- var X H Ign, !) => 
      fold-map T [] _ R.

  pred eta i:term, i:term.
  eta _ B :- var B, coq.error "link.eta error, flexible rhs".
  eta A B :- progress-eta-left A A', !, /*coq.say "Prog-lhs, lhs",*/ A' = B.
  eta A B :- progress-eta-right B B', !, /*coq.say "Prog-rhs",*/ A = B'. 
  eta A B :- get-vars B L, declare_constraint (eta A B) [A|L].
}

kind nat type.
type z nat.
type s nat -> nat.

pred count-prod i:term , o:nat.
count-prod (prod _ _ B) (s N) :- !, pi x\ count-prod (B x) N.
count-prod _ z.

pred length i:list A, o:nat.
length [] z.
length [_|L] (s N) :- length L N.

% [var-mem F Ar H Ty]
% we associate the FO variable F, to the HO variable H 
% with airty Ar and type Ty
pred var-mem o:term, o:any, o:nat, o:term.

pred locally-bound o:term.

% TODO: need to also return link, for the moment only compile ho-vars
pred fo-to-ho-aux i:term, o:term. %, o:list prop.
fo-to-ho-aux (app [T|L]) R :-
  std.forall L locally-bound,
  distinct_names L,
  length L Len,
  var-mem T V Len Ty_, !,
  std.unsafe-cast V V',
  name R V' L.

fo-to-ho-aux (fun A T B) (fun A T B') :- !,
  pi x\ locally-bound x => fo-to-ho-aux (B x) (B' x).

pred fo-to-ho i:term, o:term, o:list prop.
fo-to-ho T T1 [] :-
  (pi x y\ copy x y :- fo-to-ho-aux x y, !) => copy T T1.
