namespace tc {

  namespace precomp {
    pred count-prod i:term , o:nat.
    count-prod (prod _ _ B) (s N) :- !, pi x\ count-prod (B x) N.
    count-prod _ z.

    namespace instance {
      % Tells if the current name is a bound variables
      pred is-name o:term.
      % Tells if the current name stands for a uvar
      pred is-uvar o:term.

      :index (_ _ 1)
      pred may-contract-to i:list term, i:term, i:term.
      may-contract-to _ N N :- !.
      may-contract-to L N (app [V|S]) :- is-uvar V, !,
        std.forall [N|L] (x\ exists! S (may-contract-to [] x)).
      may-contract-to L N (app [N|A]) :-
        std.length A {std.length L},
        std.forall2 {std.rev L} A (may-contract-to []).
      may-contract-to L N (fun _ _ B) :-
        pi x\ may-contract-to [x|L] N (B x).

      :index (_ 1)
      pred occurs-rigidly i:term, i:term.
      occurs-rigidly N N :- name N, !.
      occurs-rigidly _ (app [N|_]) :- is-uvar N, !, fail.
      occurs-rigidly N (app A) :- exists! A (occurs-rigidly N).
      occurs-rigidly N (fun _ _ B) :- pi x\ occurs-rigidly N (B x).

      pred maybe-eta-aux i:term, i:list term.
      maybe-eta-aux (app[V|S]) L :- is-uvar V, !,
        std.forall L (x\ exists! S (y\ may-contract-to [] x y)).
      maybe-eta-aux (app [_|A]) L :-
        SplitLen is {std.length A} - {std.length L},
        split-at-not-fatal SplitLen A HD TL,
        std.forall L (x\ not (exists! HD (occurs-rigidly x))),
        std.forall2 {std.rev L} TL (may-contract-to []). 
      maybe-eta-aux (fun _ _ B) L :-
        pi x\ maybe-eta-aux (B x) [x|L].

      pred maybe-eta i:term.
      maybe-eta (fun _ _ B) :- pi x\ maybe-eta-aux (B x) [x].

      % pred is-maybe-llam i:list term, i:list term, o:list term, o:list term.
      % is-maybe-llam [] _ _ _ :- !, fail.
      % is-maybe-llam [X|L] PF [X|XS] NPF :-
      %   is-name X, not (std.mem! PF X), !, 
      %   is-maybe-llam L [X|PF] XS NPF.
      % is-maybe-llam L PF PF L.

      pred free-var o:list term.
      free-var L :-
        std.findall (is-name _) T,
        std.map T (x\y\ x = is-name y) L.

      pred split-pf i:list term, o:list term, o:list term.
      split-pf [] [] [] :- !.
      split-pf [X|Xs] [X|Ys] L :- is-name X, not (std.mem! Xs X), !, split-pf Xs Ys L.
      split-pf Xs [] Xs.

      pred precompile-aux i:bool, i:term, i:A, o:term, o:A.
      precompile-aux _ X A Y A :- name X, !, X = Y, !. % avoid loading "precompile-aux x A x A" at binders
      precompile-aux _ (global _ as C) A C A :- !.
      precompile-aux _ (pglobal _ _ as C) A C A :- !.
      precompile-aux _ (sort _ as C) A C A :- !.

      % Detect maybe-eta term
      precompile-aux IsP (fun Name Ty B as T) N (tc.maybe-eta-tm (fun Name Ty B') Scope) (s M) :-
        % free-var (fun Name Ty B) Scope,
        (pi x\ maybe-eta T), !,
        free-var Scope,
        (pi x\ is-name x => precompile-aux IsP (B x) N (B' x) M).

      % Detect maybe-llam term
      % TODO: detect maybe-llam
      precompile-aux IsP (app [X|XS]) N (tc.maybe-llam-tm (app [app[X | PF] | NPF1]) Scope) (s M) :-
        is-uvar X, split-pf XS PF NPF, 
        not (NPF = []), !, % else XS is a list of distinct names, i.e. `app [X|XS]` is in PF
        free-var Scope,
        std.fold-map NPF N (precompile-aux IsP) NPF1 M. 

      % Charge if we work with unification variable or local name
      % And returns the subterms is a maybe-beta-tm
      precompile-aux IsP (prod Name Ty B) N (tc.maybe-beta-tm (prod Name Ty' B') MaxAr) P :- !,
        % std.assert! (pi x\ count-maximal-arity x (B x) MaxAr) "[TC] count-maximal-arity should not fail",
        count-prod Ty MaxAr,
        if (IsP = tt) (C = x\ is-uvar x) (C = x\ is-name x),
        std.assert! (pi x\ C x => precompile-aux IsP (B x) N (B' x) M) "[TC] should not fail",
        precompile-aux {neg IsP} Ty M Ty' P.

      % Working with fun
      precompile-aux IsP (fun N T F) A (fun N T F1) A2 :- !, A = A1,
        /*precompile-aux IsP T A T1 A1,*/ pi x\ is-name x => precompile-aux IsP (F x) A1 (F1 x) A2.
      
      precompile-aux IsP (app L) A (app L1) A1 :- !, std.fold-map L A (precompile-aux IsP) L1 A1.

      % TODO: what about the following constructors?
      % precompile-aux IsP (let N T B F) A (let N T1 B1 F1) A3 :- !,
      %   precompile-aux IsP T A T1 A1, precompile-aux IsP B A1 B1 A2, pi x\ is-name x => precompile-aux IsP (F x) A2 (F1 x) A3.
      % precompile-aux IsP (fix N Rno Ty F) A (fix N Rno Ty1 F1) A2 :- !,
      %   precompile-aux IsP Ty A Ty1 A1, pi x\ is-name x => precompile-aux IsP (F x) A1 (F1 x) A2.
      % precompile-aux IsP (match T Rty B) A (match T1 Rty1 B1) A3 :- !,
      %   precompile-aux IsP T A T1 A1, precompile-aux IsP Rty A1 Rty1 A2, std.fold-map B A2 (precompile-aux IsP) B1 A3.
      % precompile-aux _ (primitive _ as C) A C A :- !.
      % precompile-aux IsP (uvar M L as X) A W A1 :- var X, !, std.fold-map L A (precompile-aux IsP) L1 A1, coq.mk-app-uvar M L1 W.
      % % when used in CHR rules
      % precompile-aux IsP (uvar X L) A (uvar X L1) A1 :- std.fold-map L A (precompile-aux IsP) L1 A1.

      pred get-univ-instances i:term, o:list univ-instance.
      get-univ-instances T L :-
        (pi x L\ fold-map (pglobal _ x) L _ [x | L]) => fold-map T [] _ L.

      pred get-univ i:term, o:list univ.
      get-univ T L :-
        coq.univ.variable.set.elements {coq.univ.variable.of-term T} Vars,
        std.map Vars (x\r\ coq.univ.variable r x) L.

    }

    /*
      [tc.precomp.instance T T' N] 
      Returns T' N from T, where: 
        T' is obtained by the replacement of
          - all maybe-eta term `t1` with (tc.maybe-eta-tm `t1` `s`) where `s` = FV(`t1`)
              ==> This helps knowing if a subterm should be replaced with a `eta-link`
          - all `prod _ Ty (x\ Bo x)` with (tc.maybe-beta-tm (prod _ Ty (x\ Bo x)) N), 
            where N is the number of prod in Ty
            TODO: it is better to only charge the `right` number of link-eta, that is the maximal 
                  application of each uvars
                  for example:
                    prod _ (Type -> Type -> Type -> Type -> Type) (x\ c1 (x nat bool) (x nat) (x nat nat bool)).
                  is replace with
                    (tc.maybe-beta-tm (prod _ (Type -> Type -> Type -> Type -> Type) (x\ c1 (x nat)) 3)
                  since x is applied at most 3 times in the original term
                    ==> This helps charging the right number of `eta-link` for map-deduplication rule
        N is the number of problematic terms in T
    */
    pred instance i:term, o:term, o:nat.
    instance T T' N :-
      instance.precompile-aux tt T z T' N.

    namespace goal {
      :index (_ _ 1)
      pred may-contract-to i:list term, i:term, i:term.
      may-contract-to _ N N :- !.
      % TODO: here we should do var V _ Scope and use scope: N can be in Scope but not in S
      may-contract-to L N (app [V|S]) :- var V, !,
        std.forall [N|L] (x\ exists! S (may-contract-to [] x)).
      may-contract-to L N (app [N|A]) :-
        std.length A {std.length L},
        std.forall2 {std.rev L} A (may-contract-to []).
      may-contract-to L N (fun _ _ B) :-
        pi x\ may-contract-to [x|L] N (B x).

      :index (_ 1)
      pred occurs-rigidly i:term, i:term.
      occurs-rigidly N N :- name N, !.
      occurs-rigidly _ (app [N|_]) :- var N, !, fail.
      occurs-rigidly N (app A) :- exists! A (occurs-rigidly N).
      occurs-rigidly N (fun _ _ B) :- pi x\ occurs-rigidly N (B x).

      pred maybe-eta-aux i:term, i:list term.
      % TODO: here we should do var V _ Scope and use Scope: an elt in L can appear in Scope
      maybe-eta-aux (app[V|S]) L :- var V, !,
        std.forall L (x\ exists! S (y\ may-contract-to [] x y)).
      maybe-eta-aux (app [_|A]) L :-
        SplitLen is {std.length A} - {std.length L},
        split-at-not-fatal SplitLen A HD TL,
        std.forall L (x\ not (exists! HD (occurs-rigidly x))),
        std.forall2 {std.rev L} TL (may-contract-to []). 
      maybe-eta-aux (fun _ _ B) L :-
        pi x\ maybe-eta-aux (B x) [x|L].

      pred maybe-eta i:term.
      maybe-eta (fun _ _ B) :- pi x\ maybe-eta-aux (B x) [x].

      pred precompile-aux i:term, i:list term, o:term, o:list term.
      precompile-aux X A Y A :- name X, !, X = Y, !. % avoid loading "precompile-aux x A x A" at binders
      precompile-aux (global _ as C) A C A :- !.
      precompile-aux (pglobal _ _ as C) A C A :- !.
      precompile-aux (sort _ as C) A C A :- !.

      % Detect maybe-eta term
      precompile-aux (fun Name Ty B as T) N (tc.maybe-eta-tm (fun Name Ty B') Scope) M :-
        names Scope,
        pi x\ maybe-eta T, !,
        (pi x\ precompile-aux (B x) N (B' x) M).

      % Charge if we work with unification variable or local name
      % And returns the subterms is a maybe-beta-tm
      precompile-aux (prod Name Ty B) N (tc.maybe-beta-tm (prod Name Ty' B') MaxAr) P :- !,
        count-prod Ty MaxAr,
        std.assert! (pi x\ precompile-aux (B x) N (B' x) M) "[TC] should not fail",
        precompile-aux Ty M Ty' P.

      % Working with fun
      precompile-aux (fun N T F) A (fun N T F1) A2 :- !, A = A1,
        /*precompile-aux IsP T A T1 A1,*/ pi x\ precompile-aux (F x) A1 (F1 x) A2.
      
      precompile-aux (app L) A (app L1) A1 :- !, std.fold-map L A precompile-aux L1 A1.
      precompile-aux (let N T B F) A (let N T1 B1 F1) A3 :- !,
        precompile-aux T A T1 A1, precompile-aux B A1 B1 A2, pi x\ precompile-aux (F x) A2 (F1 x) A3.
      precompile-aux (fix N Rno Ty F) A (fix N Rno Ty1 F1) A2 :- !,
        precompile-aux Ty A Ty1 A1, pi x\ precompile-aux (F x) A1 (F1 x) A2.
      precompile-aux (match T Rty B) A (match T1 Rty1 B1) A3 :- !,
        precompile-aux T A T1 A1, precompile-aux Rty A1 Rty1 A2, std.fold-map B A2 precompile-aux B1 A3.
      precompile-aux (primitive _ as C) A C A :- !.
      precompile-aux X A X [X|A] :- var X, !.
    }

    pred goal i:term, o:term, o:list term.
    goal T T' Vars' :- goal.precompile-aux T [] T' Vars, undup-same Vars Vars'. 
  }
}