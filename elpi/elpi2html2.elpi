/* elpi: embedded lambda prolog interpreter                                  */
/* license: GNU Lesser General Public License Version 2.1 or later           */
/* ------------------------------------------------------------------------- */

accumulate elpi-quoted_syntax.

shorten std.{spy, rev, exists}.

pred escape-double-tick i:string, o:string.
escape-double-tick A B :- 
  rex.replace "\"" "\\\"" A B.

pred iter i:(A -> prop), o:list A.
iter _ [].
iter P [X|XS] :- P X, iter P XS.

pred iter-sep i:string, i:(A -> prop), i:list A.
iter-sep _ _ [].
iter-sep S P [X] :- !, P X.
iter-sep S P [X|XS] :- P X, write S, iter-sep S P XS.

pred iter-sep-end i:string, i:string, i:(A -> prop), i:list A.
iter-sep-end _ _ _ [].
iter-sep-end S End P [X] :- !, P X.
iter-sep-end S End P [X|XS] :- P X, write S, iter-sep-end S End P XS, write End.

pred iter-sep2 i:string, i:string, i:(A -> prop), i:list A.
iter-sep2 _ _  _ [].
iter-sep2 S _  P [X] :- !, P X.
iter-sep2 S S1 P [X|XS] :- P X, write S, iter-sep2 S S1 P XS.

pred monad i:list (S -> S -> prop), i:S, o:S.
monad [] X X.
monad [P|PS] X R :- P X X1, monad PS X1 R. 

pred len i:list A, o:int.
len uvar 0.
len [] 0.
len [_|XS] N :- len XS M, N is M + 1.

pred write-to o:ctype "out_stream".
pred write i:string.
write S :- write-to OC, output OC S.

pred sanitize i:string, o:string.
sanitize X Y :-
  monad [
    rex_replace "&" "&amp;",
    rex_replace "<" "&lt;",
    rex_replace ">" "&gt;",
    rex_replace "\"" "&quot;",
    rex_replace "'" "&apos;" ]
  X Y.

pred mk-name i:string, i:term, o:string.
mk-name S1 I Y :-
  Y is "{\"id\":\"var\", \"cnt\":\"" ^ S1 ^ "\"}".

pred cur-int o:int.
pred incr-int i:prop.
incr-int P :- cur-int J, I is J + 1, (cur-int I :- !) => P.

pred var-to-string i:A, i:B, o:string.
var-to-string X I Y :-
  cur-int J, S1 is "x " ^ {term_to_string J},
  mk-name S1 I Y.
pred uvar-to-string i:A, i:B, o:string.
uvar-to-string X I Y :-
  cur-int J, S1 is "X " ^ {term_to_string J} ^ "",
  mk-name S1 I Y.
pred name-to-string i:string, i:B, o:string.
name-to-string X0 I Y :-
  if (rex_match "^_" X0) (X = "_") (X = X0),
  rex_replace "^\\([A-Za-z]+\\)_?\\([0-9]+\\)_?$" "\\1 \\2" X S1,
  mk-name S1 I Y.

pred concat i:list string, o:string.
concat [] "".
concat [X|XS] S :- concat XS Res, S is X ^ Res.

pred par? i:int, i:int, i:list string, i:list string, o:list string, o:list string.
par? CL PL Open Close Open1 Close1 :-
  if (CL =< PL)
     (Open1 = Open, Close1 = Close)
     (Open1 = [""|Open], Close1 = [""|Close]).

kind option type -> type.
type some A -> option A.
type none option A.

pred grab-list i:term, o:list term, o:option term.
grab-list (const "[]") [] none.
grab-list (app [ const "::", X, XS]) [ X | R ] T :- grab-list XS R T.
grab-list X [] (some X).


pred infx i:string, o:int, o:string, o:int, o:int.
% TODO: fix precendences
infx "<"  60 "&nbsp;&lt;&nbsp;"      60 60.
infx ">"  60 "&nbsp;&lt;&nbsp;"      60 60.
infx "=>" 60 "&nbsp;<b>â‡’</b>&nbsp;"  59 59.
infx "="  60 "&nbsp;=&nbsp;"           70 70.
infx "^"  60 "&nbsp;^&nbsp;"           60 60.
infx "is" 60 "&nbsp;<b>is</b>&nbsp;" 60 60.
infx ";"  50 "&nbsp;;&nbsp;"         50 50.
infx "+"  60 "&nbsp;+&nbsp;"           60 60.
infx "*"  60 "&nbsp;*&nbsp;"           60 60.
infx "as"  0 "&nbsp;<b>as</b>&nbsp;" 60 60.

%@log (pp _ _ _ _).

pred pp-compound i:prop.
pp-compound P :- P.

%    pp Level  ParensBefore   Term    ParensAfter
pred pp i:int, i:list string, i:term, i:list string.
pp L B (app [ const OP, Left, Right ]) A :- infx OP LOP S PL PR, !,
  par? L LOP B A B1 A1, 
  write "{\"id\":\"propInfix\", \"cnt\": {\"args\":[\n{\"id\":\"const\", \"cnt\":\"",
  write OP, write "\"}, ",
  pp-compound (pp PL B1 Left  []), write ",",
  pp-compound (pp PR [] Right A1),
  write "]}}".

pp L B (app [ const ":-" , Hd , Hyps ]) A :-
  par? L 60 B A B1 A1,
  if (Hyps = app [ const "," , const "!" | Rest])
     (Hyps2 = app [ const "," | Rest], NeckCut = " neckcut")
     (Hyps2 = Hyps, NeckCut = ""),
  write "{\"id\":\"clause\", \"cnt\":{\"hyp\":[\n",
  pp 59 B1 Hyps2 [],
  write "],\n",
  Concl is "\"args\":[",
  write Concl,
  pp 59 [] Hd A1,
  write "]}}".

pp L B (app [ const C, lam _ ] as T) A :- (C = "pi"; C = "sigma"), !,
  par? L 60 B A B1 A1,
  pp-quantifier-block B1 C T [] A1.

pred pp-quantifier-block i:list string, i:string, i:term, i:list string, i:list string.
pp-quantifier-block B C (app [ const C, lam F ]) Args A :- !, incr-int (
  new_int I,
  pi x\ if (C = "pi") (var-to-string x I X) (uvar-to-string x I X),
        is-name x X => pp-quantifier-block B C (F x) [X|Args] A).
pp-quantifier-block B C T Args A :-
  write "{\"id\": \"quantification\",\n \"cnt\":{\n\"type\":",
  write-math-quantifier B C,
  write ",\"names\":[",
  iter-sep ", " (x\ write "", write x, write "") {rev Args},
  write "],\n\"body\":[",
  pp 60 [] T A,
  write "]}}".

pred write-math-quantifier i:list string, i:string.
write-math-quantifier B "pi"    :- write {concat B}, write "\"forall\"".
write-math-quantifier B "sigma" :- write {concat B}, write "\"exists\"".

pp L B (app [ const "," | Args ]) A :-
  par? L 60 B A B1 A1,
  iter-sep2 "," "" (x\ pp 59 B x A) Args.

pp L B (app [ const "::", HD, TL ]) A :-
  par? L 99 B A B1 A1,
  grab-list TL Args Last,
  write "{\"id\":\"list\", \"cnt\":",
  write "{\"l\":[",
  iter-sep2 "," "" (x\ pp 59 B x A) [HD|Args],
  write "]",
  if (Last = some X) (write ",\"tl\":", pp 0 [] X [], write "") (true),
  write "}}", write {concat A1}.

pp L B (app Args) A :-
  par? L 65 B A B1 A1,
  write "[",
  % std.iter Args (x\ pp 66 ).
  iter-sep-end ", " "" (x\ pp 59 B x A) Args,
  write "]".

pp L B (lam F) A :- incr-int (
  par? L 70 B A B1 A1,
  new_int I,
    pi x\ 
    write "{\"id\": \"quantification\",\n \"cnt\":{\n\"type\":\"anonymousForall\"",
    write ",\"names\":[",
    write {concat B1},
    var-to-string x I X, write X,
    write "], \n\"body\":[",
    is-name x X => pp 10 [] (F x) A1,
    write "]}}\n").

pp _ B (const "!") A :- !,
  write {concat B},
  write "{\"id\":\"cut\"}",
  write {concat A}.

pp _ B (const "discard") A :-
  write {concat B},
  write "{\"id\":\"discard\"}",
  write {concat A}.

pp _ B (const X) A :-
  write {concat B},
  write "{\"id\":\"const\", \"cnt\":\"",
  write X,
  write "\"}".

pp _ B X A :- is-name X Y, !,
  write {concat B}, 
  write Y, 
  write {concat A}.

pp _ B (cdata S) A :- is_cdata S _, !,
  term_to_string S Y,
  write {concat B},
  write "{\"id\":\"string\", \"cnt\":\"", 
  % rex.replace "\\" "\\\\" Y Y',
  rex.replace "\\\." "\\\\\." Y Y',
  write Y',
  write "\"}",
  write {concat A}.

pp _ B X A :- write "ERROR".

pred hd-symbol i:term.
hd-symbol (app [ const ":-", H, _ ]) :- hd-symbol H.
hd-symbol (app [ const S | _ ]) :- write S.
hd-symbol (const S) :- write S.

type is-name term -> string -> prop.
pred write-clause i:clause.
write-clause (clause Loc [] (arg Body)) :-
  new_int I, 
  (pi x\ X is "X" ^ {term_to_string I}),
  name-to-string X I A1,
  pi x\ is-name x A1 => write-clause (clause Loc [] (Body x)).
write-clause (clause Loc [A|Args] (arg Body)) :-
  new_int I, name-to-string A I A1,
  pi x\ is-name x A1 => write-clause (clause Loc Args (Body x)).
write-clause (clause Loc [] C) :- !,
  write "{ \"id\":\"clause\", \n\"title\":\"",
    term_to_string Loc LocS, write {escape-double-tick LocS},
    write "\", \n\"cnt\":",
  cur-int 0 =>
  if (C = app [const ":-"|_])
     (pp 0 [] C [])
     (write "{\"id\":\"clause\", \"cnt\":{\"hyp\":[],\n \"args\":[",
       pp 0 [] C [],
      write "]}}"),
  write "}\n".

pred filter-out i:list A, i:(A -> prop), o:list A.
filter-out [] _ [].
filter-out [X|XS] P R :-
  if (P X) (R = [X | RS]) (R = RS),
  filter-out XS P RS.

pred write-html i:list clause, i:string, i:(string -> prop).
write-html P F R :-
  filter-out P (c\
    sigma Loc LocS \ c = (clause Loc _ _), 
    term_to_string Loc LocS, not(R LocS)) [HD | TL],
  write "{\n\"clauses\":[\n",
  write-clause HD,
  iter (x\ write ",\n", write-clause x) TL,
  write "]}".

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

pred main-quoted i:list clause, i:string, i:list string.

% entry point from a software having the program in compiled form
main-quoted P OUT FILTERS :-
  open_out OUT OC,
  R = (x\exists FILTERS (y\ rex_match y x)),
  write-to OC => write-html P OUT R,
  close_out OC.

pred main i:list string.
type main prop.

% entry point from the command line
main [IN,OUT|FILTERS] :- !,
  quote_syntax IN "main" P _,
  main-quoted P OUT FILTERS.

main _ :- usage.
main.

usage :-
  halt "usage: elpi elpi2html.elpi -exec main -- in out [filter]".

% vim: set ft=lprolog:
