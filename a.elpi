kind term type.
type app list term -> term.
type atom string -> term.

kind clause type.
type clause term -> list term -> clause.
type lambda (term -> clause) -> clause.

namespace generalize_evar {
    % we add a new constructor to terms to represent terms to be abstracted
  type abs int -> term.

  pred copy i:term, o:term.
  copy (app L) (app L1) :- std.map L copy L1.
  copy (atom A) (atom A).

  pred fold-map i:term, i:A, o:term, o:A.
  fold-map (app L) A (app L1) A1 :- std.fold-map L A fold-map L1 A1.
  fold-map (atom X) A (atom X) A.


  % bind back abstracted subterms
  pred bind i:int, i:int, i:term, o:clause.
  bind I M T T1 :- M > I, !,
    T1 = lambda B,
    N is I + 1,
    pi x\                           % we allocate the fresh symbol for (abs M)
      (copy (abs N) x :- !) =>      % we schedule the replacement (abs M) -> x
      bind N M T (B x).
  bind M M T T1 :- copy T T1', T1 = clause T1' [].         % we perform all the replacements

  % for a term with M holes, returns a term with M variables to fill these holes
  % the clause see is only generated for a term if it hasn't been seen before
  % the term might need to be typechecked first or main generates extra holes for the
  % type of the parameters
  pred abs-evars i:term, o:clause, o:int.
  abs-evars T1 T3 M :- std.do! [
    % we put (abs N) in place of each occurrence of the same hole
    (pi T Ty N N' M \ fold-map T N (abs M) M :- var T, not (seen? T _), !, M is N + 1, seen! T M) =>
    (pi T N M \ fold-map T N (abs M) N :- var T, seen? T M, !) =>
      fold-map T1 0 T2 M,
    % we abstract M holes (M abs nodes)
    bind 0 M T2 T3,
    % cleanup constraint store
    purge-seen!,
  ].

  % all constraints are also on _ so that they share
  % a variable with the constraint to purge the store

  % we query if the hole was seen before, and if so
  % we fetch its number
  pred seen? i:term, o:int.
  seen? X Y :- declare_constraint (seen? X Y) [X,_].

  % we declare it is now seen and label it with a number
  pred seen! i:term, i:int.
  seen! X Y :- declare_constraint (seen! X Y) [X,_].

  % to empty the store
  pred purge-seen!.
  purge-seen! :- declare_constraint purge-seen! [_].

  constraint seen? seen! purge-seen!  {
    % a succesful query, give the label back via M
    rule (seen! X N) \ (seen? X M) <=> (M = N).
    % an unsuccesful query
    rule             \ (seen? X _) <=> false.

    rule purge-seen! \ (seen! _ _).
    rule \ purge-seen!.
  }
}

pred acc o:clause.
acc (clause (app [atom "F", atom "0"]) []).
acc (lambda (x\ clause (app [atom "F", app [atom "S", x]]) [app [atom "F", x]])).

pred findall-arity-one i:(A -> prop), o:list A.
findall-arity-one P R :-
  std.findall (P _) L,
  std.map L (x\r\ x = P r) R.

pred destruct-clause i:clause, o:term, o:list term.
destruct-clause (clause A B) A B.
destruct-clause (lambda A) B C :- sigma x\ destruct-clause (A x) B C.

pred entry-point i:int, i:list clause i:list clause, i:term, o:term.
entry-point Depth [HD|_] P T R :-
  destruct-clause HD Hd Tl, Hd = T,
  precompile-list Depth P Tl New-Hyps,
  R = app [T | New-Hyps].
entry-point Depth [_|TL] P T R :-
  entry-point Depth TL P T R.


% [precompile-list Depth Program Hyps R]
% - Depth is the depth of search
% - Program is the list of clauses of the program
% - Hyps is the list of premisis of a clause
% - R is the list of new premisis
pred precompile-list i:int, i:list clause, i:list term, o:list term.
precompile-list _ _ [] [] :- !.
precompile-list 0 _ P P :- !.
precompile-list Depth P [H0 | Hyps] R :-
  Depth > 0,
  Depth1 is Depth - 1,
  solve-hyp-loop Depth1 P P H0 HD,
  precompile-list Depth1 P Hyps TL,
  std.append HD TL R.

% [solve-hyp-loop Depth Program ProgramMem Hyp Res]
% Solve the current Hyp by looping to the current program, ProgramMem
% is the entire program and is used to do the recursive calls
pred solve-hyp-loop i:int, i:list clause, i:list clause, i:term, o:list term.
% TODO: following rules should be applied only if no other solution is possible
solve-hyp-loop _ [] _ HD [HD] :- !.
solve-hyp-loop Depth [HD|_] P Hyp R :- solve-hyp Depth P HD Hyp R.
solve-hyp-loop Depth [_|TL] P Hyp R :- solve-hyp-loop Depth TL P Hyp R.

% [solve-hyp Depth Program CurrentClause CurrentHyp Res]
% Tries to solve CurrentHyp with the CurrentClause and gives
% back Res, that is the list of remaining hypothesis
pred solve-hyp i:int, i:list clause, i:clause, i:term, o:list term.
solve-hyp Depth P (clause Head Hyps) Hd Res :- !,
  % print "the head is" Head "and the hyps is" Hyps "with head" Hd,
  Head = Hd,
  % print "------------------------------------ the head match ------------------------------------",
  precompile-list Depth P Hyps Res.
  % print "Should be at least one time".
solve-hyp Depth P (lambda F) Hd Res :-
  solve-hyp Depth P (F D_) Hd Res.

main :-
  findall-arity-one acc R,
  entry-point 1 R R (app [(atom "F"), F_]) A,
  generalize_evar.abs-evars A B _,
  print "After compilation",
  print B.