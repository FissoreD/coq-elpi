/* license: GNU Lesser General Public License Version 2.1 or later           */
/* ------------------------------------------------------------------------- */

/*
when solving a goal in tc, we want to trigger the declared evar only after
the proof search. This means that, while the search is performed, we do not
risk to assign too early incorrect types (for example with wrong universes).
The evar typechecking is triggered after the search, just before refining the
proof with the original goal.
We use the guard declare-evars-now that to trigger the constraints to reproduce
this behavior. 
*/
pred declare-evar-later i:list prop, i:term, i:term, i:term.
pred declare-evars-now.

constraint declare-evar-later declare-evars-now {
   rule declare-evars-now \ (declare-evar-later Ctx RawEv Ty Ev) <=> (declare-evars-now, Ctx => evar RawEv Ty Ev).
}

declare-evars-now :-
  declare_constraint declare-evars-now [_].

% We want to deactivate the evar declaration if coming from the
% original goal (the original type class problem to be solved)
% :before "default-declare-evar"
% :name "tc-solver-declare-evar"
% declare-evar Ctx X Ty E :- !,
%   declare_constraint (declare-evar-later Ctx X Ty E) [_].

pred time-solve i:prop.
time-solve P :-
  std.time P Time,
  if-true (is-option-active oTC-time) 
    (coq.say "[TC] Total resolution time is:" Time).

pred is-reversed.

msolve L N :- is-reversed, !,
  time-solve (coq.ltac.all (coq.ltac.open solve-aux) {std.rev L} N).

msolve L N :- !, 
  time-solve (coq.ltac.all (coq.ltac.open solve-aux) L N).

% [section-var->decl.aux L R] auxiliary function for `section-var->decl`
pred section-var->decl.aux i:list constant, o:list prop.
section-var->decl.aux [] [].
section-var->decl.aux [X|XS] [Y|YS] :-
  coq.env.typeof (const X) Ty,
  Y = (decl (global (const X)) _ Ty),
  section-var->decl.aux XS YS.

% [section-var->decl L] decl representing seciton variables with their types
pred section-var->decl o:list prop.
section-var->decl L :-
  section-var->decl.aux {coq.env.section} L.

% [build-hypotheses Ctx Hyps] returns the list of hypotheses, made of the
% variables in the context and the current section
pred build-hypotheses i:list prop, o:list prop.
:name "build-hypotheses"
build-hypotheses Ctx Clauses :-
  std.append Ctx {section-var->decl} CtxAndSection,
  compile-ctx CtxAndSection Clauses. 

pred build-query-from-goal i:term, i:term, o:prop, o:list prop.
build-query-from-goal Goal Proof Q PostProcess :-
  % modes-check Goal, !,
  % check-problematic-term Goal Goal' PostProcess,
  % coq.safe-dest-app Goal (global TC) TL',
  % std.append TL' [Proof] TL,
  % coq.elpi.predicate {gref->pred-name TC} TL Q.
  modes-check Goal, !,
  tc.compile.goal Goal Goal' PostProcess, !,
  coq.safe-dest-app Goal' (global TC) TL',
  std.append TL' [Proof] TL, !,
  coq.elpi.predicate {gref->pred-name TC} TL Q.


% [tc-recursive-search Goal Solution] takes the type of the goal and solves it
pred tc-recursive-search i:term, o:term.
tc-recursive-search Goal Proof :- 
  std.time (
    build-query-from-goal Goal Proof Q PostProcess,
    do PostProcess,
    Q
  ) Time,
  if-true (is-option-active oTC-time-instance-search) 
    (coq.say "[TC] Instance search time is:" Time).

pred refine-proof i:term, i:goal, o:list sealed-goal.
refine-proof Proof G GL :-
  if (is-option-active oTC-ignore-eta-reduction) 
    (Proof' = Proof) (coq.reduction.eta-contract Proof Proof'),
  if-true (print-solution) (coq.say "[TC] The proof is <<<" Proof ">>>"),
  
  % here we trigger the evars assignment
  if-false declare-evars-now 
    (coq.warn "[TC] fail goal evars got ill-typed assignment in" Proof, fail),

  % here we refine the proof to the goal
  if-false (std.time (refine Proof' G GL) Refine-Time)
    (coq.warn "[TC] ill-typed solution" Proof, fail),
  
  % some printing
  if-true (print-solution) (coq.say "[TC] The proof typechecks"),
  if-true (is-option-active oTC-time-refine) 
    (coq.say "[TC] Refine time is:" Refine-Time).

pred solve-aux i:goal, o:list sealed-goal.
:name "solve-aux-intros"
% solve-aux (goal _ _ (prod N _ _) _ _ as G) GL :- !,
%   @no-tc! => refine (fun N _ _) G GL1,
%   coq.ltac.all (coq.ltac.open solve-aux) GL1 GL.
solve-aux (goal Ctx _A (prod N X T) B []) GL :- !,
  @pi-decl N X x\
    solve-aux (goal [decl x N X | Ctx] _A' (T x) (B' x) []) GL,
    B'' = fun N X B',
    coq.reduction.eta-contract B'' B.

:name "solve-aux-conclusion"
solve-aux (goal Ctx _ TyRaw (uvar) _ as G) GL :-
  % var Sol,
  build-hypotheses Ctx CtxClause,
  do-once (normalize-ty TyRaw Ty),
  if-true (print-goal) (coq.say "The goal is <<<" Ty ">>>"),
  CtxClause => (
    tc-recursive-search Ty Proof,
    refine-proof Proof G GL
  ).

:name "solve-aux-fail"
solve-aux (goal _ _ Ty _ _) _ :-
  coq.ltac.fail _ "[TC] fail to solve" Ty.


pred print-solution.
pred print-goal.

main _.