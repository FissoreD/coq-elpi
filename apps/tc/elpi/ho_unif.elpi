namespace old {

% HO unif heuristic: F X = f a b ~> F = f a, X = b
pred unify-FO o:list term, i:int, o:term, o:list term.
% (L, ArgsNo, Head) -> (Rigid, Flex, _)
unify-FO L ArgsNo Head Args :- var Head, not(var L), !, std.do! [
  std.length L Len,
  PrefixNo is Len - ArgsNo,
  PrefixNo > 0,
  split-at-not-fatal PrefixNo L [HD|Extra] Args,
  std.assert! (coq.mk-app HD Extra Head) "unif-FO error"
].
% (L, ArgsNo, Head) -> (Flex, Rigid, Rigid)
unify-FO L _ Head Args :- var L, not(var Head; var Args), !,
  coq.mk-app Head Args (app L).
% (L, ArgsNo, Head) -> (Rigid, Rigid, Rigid)
unify-FO L ArgsNo_ Head Args :-
  not (var L; var Head; var Args), !,
  coq.mk-app Head Args (app L).
unify-FO L _ H A :- var L, var H, !, L = [H|A].
unify-FO L _ H A :- coq.error "unif-FO mess" L H A.

pred locally-bound o:term.

pred build-fun i:term, i:A, o:term.
build-fun (prod N T Bo) V (fun N T Bo1) :- 
  is-coq-term V, !,
  pi x\ build-fun (Bo x) {coq.mk-app V [x]} (Bo1 x).
build-fun (prod N T Bo) V (fun N T Bo1) :- !,
  pi x\ build-fun (Bo x) (V x) (Bo1 x).
build-fun _ V V.

pred coq.reduction.eta-expand i:int, i:term, i:list term, o:A.
coq.reduction.eta-expand 0 P L X :- std.rev L L1, hd-beta P L1 Hd Args, coq.mk-app Hd Args X.
coq.reduction.eta-expand N P Acc (x\ Q x) :- N > 0, M is N - 1,
  pi x\ coq.reduction.eta-expand M P [x|Acc] (Q x).

pred ho-link o:term, i:term, o:A.
:name "ho-link"
% (C, E) -> (Rigid, Flex)
ho-link C Ty E :- var E, not (var C), !, 
  coq.count-prods Ty N, coq.reduction.eta-expand N C [] E.
% (C, E) -> (Flex, Rigid)
ho-link C Ty E :- var C, not (var E), !, 
  build-fun Ty E ETA, coq.reduction.eta-contract ETA C.
% (C, E) -> (Rigid, Rigid)
ho-link C Ty E :- not (var C), not (var E), !, same-eta C Ty [] E.
% (C, E) -> (Flex, Flex)
ho-link _C _Ty _E.

pred same-eta i:term, i:term, i:list term, i:A.
:name "same-eta1"
same-eta C (prod _ _ F) V E :- !, pi x\ same-eta C (F x) [x|V] (E x).
:name "same-eta2"
same-eta C _ VarsRev E :-
  coq.mk-app C {std.rev VarsRev} CVars,
  hd-beta E [] Hd Args, coq.mk-app Hd Args EVars,
  std.assert! (CVars = EVars) "eta mess".

pred coq-intros i:list term, i:list term, i:list term, o:term, o:A.
coq-intros SC [] V K K :-
  std.append SC {std.rev V} L, prune K L.
coq-intros SC [HD|L] LL (fun `elpi_intro` Ty Bo) E :-
  coq.typecheck HD Ty ok,
  pi x\ coq-intros SC L [x | LL] (Bo x) (E x).

pred apply-local-vars i:A, i:list term, o:B.
apply-local-vars T [] T.
apply-local-vars T [A | TL] X :-
  apply-local-vars (T A) TL X.

pred under-prod o:term.

pred subst-ho i:term, i:list prop, o:term, o:list prop.
% pattern fragment 
subst-ho (app [tc.maybe-beta-tm X Pos|XS]) A YXS A1 :- 
  name X, ho-twin X Pos Y _ Ty, distinct_names XS, std.forall XS locally-bound, !,
  name YXS Y XS,
  std.unsafe-cast Y Y1,
  A1 = [ho-link X Ty Y1|A].
subst-ho X A X A :- var X, !.
subst-ho (app [X|XArgs]) A R A1 :- std.do![
  var X _ XScope,
  std.append XScope XArgs Scope,
  distinct_names Scope, !,
  coq-intros XScope XArgs [] X' E,
  hd-beta X' XArgs Aaa Baa,
  coq.mk-app Aaa Baa R,
  coq.typecheck X Ty ok,
  A1 = [ ho-link X Ty E | A]].
subst-ho (tc.maybe-beta-tm X Pos) A X A1 :- name X, ho-twin X Pos Y _ Ty, !, A1 = [ho-link X Ty Y|A].
:name "FO heuristic"
subst-ho (app [tc.maybe-beta-tm X Pos|XS]) A (app L') A2 :- name X, ho-twin X Pos Y_ L Ty_, !,
  std.findall-unary under-prod LocVars,
  apply-local-vars L {std.rev LocVars} L',
  % L = L',
  std.length XS NARGS,
  std.fold-map XS A fold-map YS A1,
  A2 = [unify-FO L' NARGS X YS , /* ho-link X Ty_ Y_ */ |A1].
% A2 = [unify-FO L' NARGS X YS|A1].
% mark local binders
% subst-ho (prod N T F) A (prod N T1 F1) A2 :- !,
%   fold-map T A T1 A1, (pi x\ locally-bound x => fold-map (F x) A1 (F1 x) A2).
% subst-ho (fun N T F) A (fun N T1 F1) A2 :- !,
%   fold-map T A T1 A1, (pi x\ locally-bound x => fold-map (F x) A1 (F1 x) A2).
subst-ho (prod N T F) A (prod N T1 F1) [@pi-decl N T x\ A2 x] :- !, 
  fold-map T A T1 A1, !, (@pi-decl N T x\ locally-bound x => under-prod x => fold-map (F x) A1 (F1 x) (R x)), 
  A2 = (x\ (do (R x))).
subst-ho (fun N T F) A (fun N T1 F1) [@pi-decl N T x\ A2 x] :- !, 
  fold-map T A T1 A1, !, (@pi-decl N T x\ locally-bound x => under-prod x => fold-map (F x) A1 (F1 x) (R x)), 
  A2 = (x\ (do (R x))).
subst-ho (tc.maybe-beta-tm A _) L A L :- !.


pred ho-preprocess i:term, o:term, o:list prop.
ho-preprocess Ty TyX HOPremises :-
  (pi A B C D\ fold-map A B C D :- subst-ho A B C D, !) =>
    fold-map Ty [] TyX HOPremisesRev,
  std.rev HOPremisesRev HOPremises.
% ho-preprocess Ty TyX HOPremises :-
%   coq.error "ho-preprocess failure with" Ty TyX HOPremises.

pred ho-cleanup i:term, o:term.
ho-cleanup T T1 :- (pi X\ copy (tc.maybe-beta-tm X _) X :- !) => copy T T1.

% [ho-twin Coq ElpiHO ElpiFO CoqVarTy]
% app[Coq|Args] -> (app ElpiFO)    / unif-FO ElpiFO N Coq Args
% app[Coq|Args] -> (ElpiHO Args)   / ho-link Coq CoqVarTy ElpiHO
pred ho-twin i:term, o:int, o:A, o:list B, o:term.
ho-twin X I_ Y_ Z_ Ty :- var X, !, 
  coq.typecheck X Ty ok.

type tc.maybe-beta-tm term -> int -> term.

pred count-occurrences i:term, i:term, o:term, o:int.
count-occurrences T V T1 N :-
  (pi A A1\ fold-map V A (tc.maybe-beta-tm V A) A1 :- !, A1 is A + 1) =>
  (pi A B\ fold-map A B A B :- A = tc.maybe-beta-tm _ _, !) =>
  fold-map T 0 T1 N, !.
}

namespace link {
  pred eta-expand i:term, i:term, o:term.  
  eta-expand T1 Ty (fun _ Ty B) :- is-coq-term T1, !,
    pi x\ coq.mk-app T1 [x] (C x), check-problematic-term (C x) (B x) _. 
  eta-expand T1 Ty (fun _ Ty R) :-
    pi x\ name (R x) T1 [x].

  pred unify-under-fun i:any, i:term.
  unify-under-fun A (fun _ _ B) :- !,
    std.unsafe-cast A A', pi x\ unify-under-fun (A' x) (B x).
  unify-under-fun A B :- A = B.

  :index (_ _ 1)
  pred may-contract-to i:list term, i:term, i:term.
  may-contract-to _ N N :- !.
  may-contract-to L N V :- var V _ S, !, std.forall [N|L] (std.mem! S).
  may-contract-to L N (app [N|A]) :-
    std.length A {std.length L},
    std.forall2 {std.rev L} A (may-contract-to []).
  may-contract-to L N (fun _ _ B) :-
    pi x\ may-contract-to [x|L] N (B x).

  pred occurs-rigidly i:term, i:term.
  occurs-rigidly N N.
  occurs-rigidly N (app A) :- exists! A (occurs-rigidly N).
  occurs-rigidly N (fun _ _ B) :- pi x\ occurs-rigidly N (B x).

  pred maybe-eta-aux i:term, i:list term.
  maybe-eta-aux V L :- var V _ S, std.forall L (std.mem! S).
  maybe-eta-aux (app [_|A]) L :-
    SplitLen is {std.length A} - {std.length L},
    split-at-not-fatal SplitLen A HD TL,
    std.forall L (x\ not (exists! HD (occurs-rigidly x))),
    std.forall2 {std.rev L} TL (may-contract-to []). 
  maybe-eta-aux (fun _ _ B) L :-
    pi x\ maybe-eta-aux (B x) [x|L].

  pred maybe-eta i:term.
  maybe-eta (fun _ _ B) :- pi x\ maybe-eta-aux (B x) [x].

  pred progress-eta-left i:term, o:term.
  progress-eta-left A _ :- var A, !, fail.
  progress-eta-left (fun _ _ A) (fun _ _ A) :- !.
  progress-eta-left A A' :- (name A; is-coq-term A), !, eta-expand A _ A'.

  pred progress-eta-right i:term, o:term.
  progress-eta-right A A' :- coq.reduction.eta-contract A A', not (A = A'), !.
  progress-eta-right A A :- not (maybe-eta A), !.

  pred scope-check i:term, i:term.
  scope-check (uvar _ L) T :- prune A L, A = T, !.

  pred get-vars i:term, o:list term.
  get-vars T R :-
    (pi X H L Ign\ fold-map X L X [H|L] :- var X H Ign, !) => 
      fold-map T [] _ R.

  pred eta i:term, i:term.
  eta _ B :- var B, coq.error "link.eta error, flexible rhs".
  eta A B :- progress-eta-left A A', !, A' = B.
  eta A B :- progress-eta-right B B', !, A = B'. 
  eta A B :- scope-check A B, get-vars B L, declare_constraint (eta A B) [A|L].
}

pred close-term i:(term -> list prop), o:list prop.
close-term (x\ []) [] :- !.
close-term (x\ [X | Xs x]) [X| Xs'] :- !, close-term Xs Xs'.
close-term (x\ [X x | Xs x]) [pi x\ X x | Xs'] :- !, close-term Xs Xs'. 

kind nat type.
type z nat.
type s nat -> nat.

:index (1)
pred add-nat i:nat, i:nat, o:nat.
add-nat z N N.
add-nat (s N) M (s P) :- add-nat N M P.

pred max-nat i:nat, i:nat, o:nat.
max-nat z N N :- !.
max-nat N z N :- !.
max-nat (s N) (s M) (s P) :- max-nat N M P.

pred count-prod i:term , o:nat.
count-prod (prod _ _ B) (s N) :- !, pi x\ count-prod (B x) N.
count-prod _ z.

pred length i:list A, o:nat.
length [] z.
length [_|L] (s N) :- length L N.

% [var-mem F Ar H Ty]
% we associate the FO variable F, to the HO variable H 
% with airty Ar and type Ty
pred var-mem o:term, o:any, o:nat, o:term.

pred locally-bound o:term.
pred is-uvar o:term.

% Note: [check-problematic-term-aux T L T' L'] extends fold-map for ho compilation
%       recursive call should be done calling the fold-map predicate!
pred check-problematic-term-aux i:term, i:list prop, o:term, o:list prop.
check-problematic-term-aux (app [T|L]) Links R Links :-
  std.forall L locally-bound,
  distinct_names L,
  length L Len,
  var-mem T V Len Ty_, !,
  std.unsafe-cast V V',
  name R V' L.

check-problematic-term-aux (fun A T B) OldLinks (fun A T B') Links :- !,
  (pi x\ locally-bound x => fold-map (B x) OldLinks (B' x) (Links' x)),
  close-term Links' Links.

pred check-problematic-term i:term, o:term, o:list prop.
check-problematic-term T T1 Links :-
  (pi x y l1 l2\ fold-map x l1 y l2 :- check-problematic-term-aux x l1 y l2, !) => 
    fold-map T [] T1 Links.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% [tc.maybe-eta-tm T Scope] indicates that T is a maybe-eta. Scope is the list of FV occurring in T 
% type tc.maybe-eta-tm term -> list term -> term.

% Note: [fo-to-ho-aux T L T' L'] extends fold-map for ho compilation
%       recursive call should be done calling the fold-map predicate!
pred fo-to-ho-aux1 i:term, i:nat, o:term, o:nat.

pred free-var o:list term.
free-var L :-
  std.findall (locally-bound _) T,
  std.map T (x\y\ x = locally-bound y) L.

pred maybe-eta-aux-compilation i:term, i:list term.
maybe-eta-aux-compilation (app [H|S]) L :- is-uvar H, !, 
  std.forall L (x\ exists! S (y\ link.may-contract-to [] x y)).

pred may-contract-to-aux-compilation i:list term, i:term, i:term.
may-contract-to-aux-compilation L N (app [H|S]) :- is-uvar H, !, 
  std.forall [N|L] (x\ exists! S (y\ link.may-contract-to [] x y)).

fo-to-ho-aux1 (fun Name Ty B) N (tc.maybe-eta-tm (fun Name Ty B') Scope) (s M) :-
  free-var Scope,
  (pi T L\ link.maybe-eta-aux T L :- maybe-eta-aux-compilation T L, !) => 
  (pi L N T\ link.may-contract-to L N T :- may-contract-to-aux-compilation L N T) =>
    (pi x\ link.maybe-eta-aux (B x) [x]), !,
  (pi x\ locally-bound x => fold-map (B x) N (B' x) M).

fo-to-ho-aux1 (fun Name Ty B) N (fun Name Ty B') M :- !,
  pi x\ locally-bound x => fold-map (B x) N (B' x) M.

pred precompile-maybe-eta i:term, o:term, o:nat.
precompile-maybe-eta T T1 N :-
  (pi x y l1 l2\ fold-map x l1 y l2 :- fo-to-ho-aux1 x l1 y l2, !) =>
    fold-map T z T1 N.

% [close-term-ty (x\ L) Ty R] Ty is the type of x
pred close-term-ty i:(term -> list prop), i:term, o:list prop.
close-term-ty (x\ []) _ [] :- !.
close-term-ty (x\ [X | Xs x]) Ty [X| Xs'] :- !, close-term-ty Xs Ty Xs'.
close-term-ty (x\ [X x | Xs x]) Ty [@pi-decl `x` Ty x\ X x | Xs'] :- !, close-term-ty Xs Ty Xs'. 

pred build-links-aux i:term, i:pair (list term) (list prop), o:term, o:pair (list term) (list prop).
build-links-aux (tc.maybe-eta-tm T S) (pr [X|XS] L1) Y (pr XS' [NL | L2]) :-
  name Y X S,
  fold-map T (pr XS L1) T' (pr XS' L2), 
  NL = link.eta Y T'.

build-links-aux (fun Name Ty Bo) (pr XS L) (fun Name Ty Bo') (pr XS' L') :- !,
  (pi x\ locally-bound x => fold-map (Bo x) (pr XS L) (Bo' x) (pr XS' (L'' x))),
  close-term-ty L'' Ty L'.

build-links-aux (prod Name Ty Bo) (pr XS L) (prod Name Ty Bo') (pr XS' L') :- !,
  (pi x\ locally-bound x => fold-map (Bo x) (pr XS L) (Bo' x) (pr XS' (L'' x))),
  close-term-ty L'' Ty L'.

build-links-aux (app [T|L]) N R N :-
  std.forall L locally-bound,
  distinct_names L,
  length L Len,
  var-mem T V Len Ty_, !,
  std.unsafe-cast V V',
  name R V' L.

pred build-links i:term, i:list term, o:term, o:list prop, o:list term.
build-links T L R Links L' :-
  (pi x y l1 l2\ fold-map x l1 y l2 :- build-links-aux x l1 y l2, !) =>
    fold-map T (pr L []) R (pr L' Links).

namespace precompile-ho {

  pred fold-map1 i:term, i:A, o:term, o:A.
  :name "fold-map:start"
  fold-map1 X A Y A :- name X, !, X = Y, !. % avoid loading "fold-map x A x A" at binders
  fold-map1 (global _ as C) A C A :- !.
  fold-map1 (pglobal _ _ as C) A C A :- !.
  fold-map1 (sort _ as C) A C A :- !.
  fold-map1 (fun N T F) A (fun N T1 F1) A2 :- !,
    fold-map1 T A T1 A1, pi x\ fold-map1 (F x) A1 (F1 x) A2.
  fold-map1 (let N T B F) A (let N T1 B1 F1) A3 :- !,
    fold-map1 T A T1 A1, fold-map1 B A1 B1 A2, pi x\ fold-map1 (F x) A2 (F1 x) A3.
  fold-map1 (prod N T F) A (prod N T1 F1) A2 :- !,
    fold-map1 T A T1 A1, (pi x\ fold-map1 (F x) A1 (F1 x) A2).
  fold-map1 (app L) A (app L1) A1 :- !, std.fold-map L A fold-map1 L1 A1.
  fold-map1 (fix N Rno Ty F) A (fix N Rno Ty1 F1) A2 :- !,
    fold-map1 Ty A Ty1 A1, pi x\ fold-map1 (F x) A1 (F1 x) A2.
  fold-map1 (match T Rty B) A (match T1 Rty1 B1) A3 :- !,
    fold-map1 T A T1 A1, fold-map1 Rty A1 Rty1 A2, std.fold-map B A2 fold-map1 B1 A3.
  fold-map1 (primitive _ as C) A C A :- !.
  fold-map1 (uvar M L as X) A W A1 :- var X, !, std.fold-map L A fold-map1 L1 A1, coq.mk-app-uvar M L1 W.
  % when used in CHR rules
  fold-map1 (uvar X L) A (uvar X L1) A1 :- std.fold-map L A fold-map1 L1 A1.

  pred free-var o:list term.
  free-var L :-
    std.findall (locally-bound _) T,
    std.map T (x\y\ x = locally-bound y) L.

  pred maybe-eta-aux-compilation i:term, i:list term.
  maybe-eta-aux-compilation (app [H|S]) L :- name H, !, 
    std.forall L (x\ exists! S (y\ link.may-contract-to [] x y)).

  pred may-contract-to-aux-compilation i:list term, i:term, i:term.
  may-contract-to-aux-compilation L N (app [H|S]) :- name H, !, 
    std.forall [N|L] (x\ exists! S (y\ link.may-contract-to [] x y)).

  /* In the following FV is the achronym for free variables. */

  pred count-maximal-arity i:term, i:term, o:nat.
  count-maximal-arity X T N :-
    (pi L L1 N1 N2 N3 N4 N5\ fold-map1 (app [X|L]) N1 (app [X|L1]) N5 :- !, 
      length L N2,
      max-nat N1 N2 N3,
      std.fold-map L z fold-map1 L1 N4, max-nat N3 N4 N5) =>
    (pi t l t' l' a\ fold-map1 (tc.maybe-eta-tm t a) l (tc.maybe-eta-tm t a) l' :- !,
      fold-map1 t l t' l') =>
      fold-map1 T z _ N.

  pred precompile-term-aux i:term, i:nat, o:term, o:nat.
  precompile-term-aux (fun Name Ty B) N (tc.maybe-eta-tm (fun Name Ty B') Scope) (s M) :-
    % free-var (fun Name Ty B) Scope,
    free-var Scope,
    (pi T L\ link.maybe-eta-aux T L :- maybe-eta-aux-compilation T L, !) => 
    (pi L N T\ link.may-contract-to L N T :- may-contract-to-aux-compilation L N T) =>
      (pi x\ link.maybe-eta-aux (B x) [x]), !,
    (pi x\ locally-bound x => fold-map (B x) N (B' x) M).

  precompile-term-aux (fun Name Ty B) N (fun Name Ty B') M :- !,
    pi x\ fold-map (B x) N (B' x) M.

  precompile-term-aux (prod Name Ty B) N (tc.maybe-beta-tm (prod Name Ty' B') MaxAr) P :- !,
    % std.assert! (pi x\ count-maximal-arity x (B x) MaxAr) "[TC] count-maximal-arity should not fail",
    count-prod Ty MaxAr,
    std.assert! (pi x\ locally-bound x => fold-map (B x) N (B' x) M) "[TC] should not fail",
    fold-map Ty M Ty' P.

  % [precompile-term T T' N] 
  /*
    Returns T' N from T, where: 
      T' is obtained by the replacement of
        - all maybe-eta term `t1` with (tc.maybe-eta-tm `t1` `s`) where `s` = FV(`t1`)
            ==> This helps knowing if a subterm should be replaced with a `eta-link`
        - all `prod _ Ty (x\ Bo x)` with (tc.maybe-beta-tm (prod _ Ty (x\ Bo x)) N), 
          where N is the maximal application of `x` in `Bo`
          for example:
            prod _ (Type -> Type -> Type -> Type -> Type) (x\ c1 (x nat bool) (x nat) (x nat nat bool)).
          is replace with
            (tc.maybe-beta-tm (prod _ (Type -> Type -> Type -> Type -> Type) (x\ c1 (x nat)) 3)
          since x is applied at most 3 times in the original term
            ==> This helps charging the right number of `eta-link` for map-deduplication rule
      N is the number of problematic terms in T
  */
  pred precompile-term i:term, o:term, o:nat.
  precompile-term T T' N :-
    (pi x y z w\ fold-map x y z w :- precompile-term-aux x y z w, !) =>
    fold-map T z T' N.

  pred close-term-ty i:(term -> list prop), i:term, o:list prop.
  close-term-ty (x\ []) _ [] :- !.
  close-term-ty (x\ [X | Xs x]) Ty [X| Xs'] :- !, close-term-ty Xs Ty Xs'.
  close-term-ty (x\ [X x | Xs x]) Ty [@pi-decl `x` Ty x\ X x | Xs'] :- !, close-term-ty Xs Ty Xs'. 

  pred decompile-term-aux i:term, i:pair (list term) (list prop), o:term, o:pair (list term) (list prop).
  decompile-term-aux (tc.maybe-eta-tm T S) (pr [X|XS] L1) Y (pr XS' [NL | L2]) :-
    name Y X S, !,
    fold-map T (pr XS L1) T' (pr XS' L2), 
    NL = link.eta Y T'.

  decompile-term-aux (fun Name Ty Bo) (pr XS L) (fun Name Ty Bo') (pr XS' L') :- !,
    (pi x\ locally-bound x => fold-map (Bo x) (pr XS L) (Bo' x) (pr XS' (L'' x))),
    close-term-ty L'' Ty L'.

  decompile-term-aux (prod Name Ty Bo) (pr XS L) (prod Name Ty Bo') (pr XS' L') :- !,
    (pi x\ locally-bound x => fold-map (Bo x) (pr XS L) (Bo' x) (pr XS' (L'' x))),
    close-term-ty L'' Ty L'.

  decompile-term-aux (app [T|L]) N R N :-
    name T,
    std.forall L locally-bound,
    distinct_names L,
    length L (s Len),
    var-mem T V Len Ty_, !,
    std.unsafe-cast V V',
    name R V' L.

  pred decompile-term i:list term, o:list term, i:term, o:term, o:list prop.
  decompile-term L L' T R Links :-
  (pi x y l1 l2\ fold-map x l1 y l2 :- decompile-term-aux x l1 y l2, !) =>
    fold-map T (pr L []) R (pr L' Links).
}