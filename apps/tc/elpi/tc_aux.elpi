/* license: GNU Lesser General Public License Version 2.1 or later           */
/* ------------------------------------------------------------------------- */


% return if a gref is an existsing instance
% TODO: this could be replaced with an API
% coq.TC.get-class-of-inst i:gref, o:gref
pred existing-instance i:gref.
existing-instance InstGR :-
  coq.env.typeof InstGR InstTy,
  get-TC-of-inst-type InstTy ClassGR,
  coq.TC.class? ClassGR,
  coq.TC.db-for ClassGR DB, 
  std.mem! DB (tc-instance InstGR _).

pred under-p-global i:term, o:gref.
under-p-global (global GR) GR.
under-p-global (pglobal GR _) GR.

pred class-gref i:term, o:gref.
class-gref T ClassGR :- 
  under-p-global T ClassGR, 
  coq.TC.class? ClassGR.

% returns the TC from the type of an instance
% TODO: This could be replaced with an api 
% coq.TC.get-class-of-inst i:gref, o:gref
pred get-TC-of-inst-type i:term, o:gref.
get-TC-of-inst-type (prod _ _ A) ClassGR:- !,
  pi x\ get-TC-of-inst-type (A x) ClassGR.
get-TC-of-inst-type T ClassGR :-
  coq.safe-dest-app T HD _,
  not (var HD), class-gref HD ClassGR.

pred drop-last i:list A, i:list A, o:list A.
drop-last [X | XS] [Y | YS] L :-
  same_term X Y, !, drop-last XS YS L.
drop-last L [] L' :- std.rev L L'.

pred instances-of-current-section o:list gref.
:name "MySectionEndHook"
instances-of-current-section InstsFiltered :-
  coq.env.current-section-path SectionPath,
  std.findall (instance SectionPath _ _) Insts,
  coq.env.section SectionVars,
  std.map-filter Insts (x\r\ sigma X\ instance _ r _ = x, const X = r, not(std.mem SectionVars X)) InstsFiltered.

pred is-instance-gr i:gref.
is-instance-gr GR :-
  coq.env.typeof GR Ty,
  is-instance-term Ty.

pred is-instance-term i:term.
is-instance-term T :-
  get-TC-of-inst-type T TC,
  coq.TC.class? TC.

% adds a clause to the tc.db DB at the passed grafting
pred add-tc-db o:id, o:grafting, i:prop.  
add-tc-db ClauseName Graft PR :-
  if (not (ground_term PR)) (coq.error "[TC] anomaly: open rule:" PR) true,
  coq.elpi.accumulate _ "tc.db" 
    (clause ClauseName Graft PR); coq.error "cannot add " PR " to tc.db".

% takes a tc-instance and return the gref of the inst
pred inst->gref i:tc-instance, o:gref.
inst->gref (tc-instance Res _) Res.

% returns all the instances of the passed ClassName
pred get-inst-by-tc-name i:gref, o:list gref.
get-inst-by-tc-name TC GRL:-
  coq.TC.db-for TC Inst,
  std.map Inst inst->gref GRL',
  std.rev GRL' GRL. 

pred app-has-class i:term.
app-has-class T :- 
  get-TC-of-inst-type T Hd, 
  coq.TC.class? Hd. 

% input (∀ a, b, c ... => app [A, B, ..., Last])
% returns Last 
pred get-last i:term, o:term.
get-last (prod _ _ Bo) R :-
  pi x\ get-last (Bo x) R.
get-last (app L) R :-
  std.last L R.

% TC preds are on the form tc-[PATH_TO_TC].tc-[TC-Name]
pred gref->pred-name i:gref, o:string.
gref->pred-name Gr S :-
  if (is-option-active oTC-clauseNameShortName)
    (Path = "")
    (coq.gref->path Gr [Hd | Tl], 
      std.fold Tl Hd (x\acc\r\ r is acc ^ "." ^ x) Path', 
      Path is Path' ^ ".tc-"),
  % CAVEAT : Non-ascii caractars can't be part of a pred
  %          name, we replace ö with o
  rex.replace "ö" "o" {coq.gref->id Gr} GrStr,
  S is "tc-" ^ Path ^ GrStr.

pred no-backtrack i:list prop, o:list prop. 
no-backtrack [] [].
no-backtrack [do X | XS] [std.do! [(std.do! X') | XS']] :- !, 
  no-backtrack X X', no-backtrack XS XS'.
no-backtrack [X | XS] [std.do! [X | XS']] :- !, no-backtrack XS XS'.

pred get-mode i:gref, o:list string.
get-mode ClassGR M :- class ClassGR _ _ M, !.
get-mode ClassGR _ :- coq.error "[TC]" ClassGR "is an unknown class".

pred make-tc.aux i:bool, i:prop, i:list prop, o:prop.
make-tc.aux _ Head [] Head.
make-tc.aux tt Head Body (Head :- Body).
make-tc.aux ff Head Body (Body => Head).

pred make-tc i:term, i:term, i:list prop, i:bool, o:prop.
make-tc Ty Inst Body IsPositive Clause :-
  coq.safe-dest-app Ty HD TL,
  get-TC-of-inst-type HD ClassGR,
  gref->pred-name ClassGR ClassStr,
  std.append TL [Inst] Args, 
  coq.elpi.predicate ClassStr Args Head,
  make-tc.aux IsPositive Head Body Clause.

pred unwrap-prio i:tc-priority, o:int.
unwrap-prio (tc-priority-given Prio) Prio.
unwrap-prio (tc-priority-computed Prio) Prio.

% returns the priority of an instance from the gref of an instance
pred get-inst-prio i:gref, o:int.
get-inst-prio InstGR Prio :-
  coq.env.typeof InstGR InstTy,
  get-TC-of-inst-type InstTy ClassGR,
  unwrap-prio {coq.TC.get-inst-prio ClassGR InstGR} Prio.

pred get-full-path i:gref, o:string.
get-full-path Gr Res' :-
  coq.gref->string Gr Path,
  coq.env.current-section-path SectionPath,
  std.fold SectionPath "" (e\acc\r\ r is acc ^ "." ^ e) Res,
  Res' is Res ^ Path.

pred constant->redflag i:prop, o:coq.redflag.
constant->redflag (unfold-constant C) (coq.redflags.const C).

pred normalize-ty i:term, o:term.
:name "normalize-ty"
normalize-ty G1 G3 :-
  std.findall (unfold-constant _) UnfoldFindall,
  std.map UnfoldFindall constant->redflag UnfoldRF,
  coq.redflags.add coq.redflags.nored [coq.redflags.delta | UnfoldRF] RF,
  coq.redflags.add RF [coq.redflags.beta] RF1,
  @redflags! RF1 => coq.reduction.lazy.norm G1 G2,
  coq.reduction.eta-contract G2 G3.

pred dummy.

pred remove-clause i:string.
remove-clause ClauseName :-
  add-tc-db _ (replace ClauseName) dummy.

pred decompile-mapping-aux i:any, o:term.
decompile-mapping-aux A A :- (var A; is-coq-term A), !.
decompile-mapping-aux (x\ B x) (fun `fvar` TODO_ R) :- !,
  pi x\ decompile-mapping-aux (B x) (R x).

pred decompile-mapping i:any, o:term.
decompile-mapping T A :-
  decompile-mapping-aux T R, R = A.