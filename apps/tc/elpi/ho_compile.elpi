namespace tc {
  namespace compile {
    namespace goal {
      % [uvar-pair V1 Ty V2] List of uvar for link-eta-dedup
      %                      V1 has arity n and V2 has arity n+1
      %                      If V1 has type A -> B, then A = Ty
      pred uvar-pair i:term, o:term, o:term.

      %                    Type     Var    Cnt    uvar-pair-list
      pred make-pairs-aux i:term, i:term, o:list prop.
      make-pairs-aux (prod _ Ty Bo) V [pi x\ uvar-pair x Ty X' :- x == V, ! | L] :- !,
        pi x\ make-pairs-aux (Bo x) X' L.
      make-pairs-aux Ty V [pi x\ uvar-pair x Ty V_ :- x == V, !].

      pred make-pairs i:list term, o:list prop.
      make-pairs [] [] :- !.
      make-pairs [X|Xs] L :- !,
        coq.typecheck X Ty ok,
        % std.assert! (not (var Ty)) "[TC] compile: Ty should not be flex", TODO: I want decomment this line once test.v passes
        make-pairs-aux Ty X L',
        make-pairs Xs L'',
        std.append L' L'' L.

      pred get-uva-pair-arity i:term, i:list term, o:term.
      get-uva-pair-arity X [] X :- !.
      get-uva-pair-arity X [_|L] Z :- uvar-pair X _ Y, !, 
        get-uva-pair-arity Y L Z.

      pred decompile-problematic-term i:term, i:list prop, o:term, o:list prop.
      decompile-problematic-term (tc.maybe-eta-tm T S) L V [link.eta V T' | L2] :-
        prune V S, !, fold-map T L T' L2.

      % TODO: maybe-llam
      % NOTE!!! a uvar in the goal has a scope!! At a certain point shoud do (X = uvar A S') and work with S'
      decompile-problematic-term (app[X|S]) L Z L :-
        var X, distinct_names S, !,
        get-uva-pair-arity X S Y,
        prune Z S, var Z Y S.

      pred compile i:term, i:list prop, o:term, o:list prop.
      compile T L T' L' :-
        (pi t l t' l'\ fold-map t l t' l' :- decompile-problematic-term t l t' l', !) =>
          fold-map T L T' L'.

      pred close-term-no-prune-ty i:(term -> list prop), i:term, o:list prop.
      close-term-no-prune-ty (x\ []) _ [] :- !.
      close-term-no-prune-ty (x\ [X x | Xs x]) Ty [@pi-decl `x` Ty x\ X x | Xs'] :- !, 
        close-term-no-prune-ty Xs Ty Xs'. 

      %                                  Uva      Binders      LinkEta 
      pred build-eta-links-of-vars-aux i:term, i:list term, o:list prop.
      build-eta-links-of-vars-aux Old L [Hd | Xs] :- 
        uvar-pair Old Ty Next, !,
        var OldScope Old L,
        Hd = link.eta OldScope (fun _ Ty (x\ NextScope x)),
        pi x\ sigma L'\
          std.append L [x] L',
          var (NextScope x) Next L',
          build-eta-links-of-vars-aux Next L' (Ys x), !,
        sigma Closed\ (close-term-no-prune-ty Ys Ty Closed),
        Xs = Closed.
      build-eta-links-of-vars-aux _ _ [].

      pred build-eta-links-of-vars i:list term, o:list prop.
      build-eta-links-of-vars [] [].
      build-eta-links-of-vars [V|Vars] L :-
        build-eta-links-of-vars-aux V [] L',
        build-eta-links-of-vars Vars L'',
        std.append L' L'' L.
    }
    
    %          Goal    Goal'      Links
    pred goal i:term, o:term, o:list prop.
    goal Goal Goal' Links :-
      tc.precomp.goal Goal GoalPrecomp Vars, !,
      goal.make-pairs Vars Pairs,
      Pairs => (
        goal.build-eta-links-of-vars Vars EtaLinks,
        goal.compile GoalPrecomp EtaLinks Goal' Links
      ).
  }
}