% Contains the list of classes that
% cannot be compiled

% returns the TC from the type of an instance
pred get-TC-of-inst-type i:term, o:gref.
get-TC-of-inst-type (prod _ _ A) GR:-
  pi x\ get-TC-of-inst-type (A x) GR.
get-TC-of-inst-type (app [global TC | _]) TC.

pred remove-eta i:term, o:term.
remove-eta A B :- !,
  (pi F\ copy (fun _ _ x\ (app [F, x])) F) => copy A B.

pred remove-eta2 i:term, o:term.
remove-eta2 A B :- !,
  (pi F Bo\ (copy (fun _ _ Bo) R :-
    pi x\ sigma L\
      (Bo x) = app L,
      last-no-error L x,
      std.drop-last 1 L F, copy (app F) R)
  ) => copy A B. 

% % pred tc o:term, o:term.
% tc _ T _ :- var T, !, coq.say "fail on flexible function", fail.

% TODO: here we make eta reduction on the term received in input
% :name "remove-eta"
% tc A B S :-
%   coq.option.get ["UseRemoveEta"] (coq.option.bool tt),
%   remove-eta B B',
%   not (same_term B B'), !,
%   tc A B' S.

pred instances-of-current-section o:list gref.
:name "MySectionEndHook"
instances-of-current-section InstsFiltered :-
  coq.env.current-section-path SectionPath,
  std.findall (instance SectionPath _ _) Insts,
  coq.env.section SectionVars,
  std.map-filter Insts (x\r\ sigma X\ instance _ r _ = x, const X = r, not(std.mem SectionVars X)) InstsFiltered.

pred is-instance-gr i:gref.
is-instance-gr GR :-
  coq.env.typeof GR Ty,
  is-instance-term Ty.

pred is-instance-term i:term.
is-instance-term T :-
  get-TC-of-inst-type T TC,
  coq.TC.class? TC.

% adds a clause to the tc.db DB at the passed grafting
pred add-tc-db o:id, o:grafting, i:prop.  
add-tc-db ClauseName Graft PR :-
  coq.elpi.accumulate _ "tc.db" 
    (clause ClauseName Graft PR); coq.error "cannot add " PR " to tc.db".

% takes a tc-instance and return the gref of the inst
pred inst->gref i:tc-instance, o:gref.
inst->gref (tc-instance Res _) Res.

% returns all the instances of the passed ClassName
pred get-inst-by-tc-name i:gref, o:list gref.
get-inst-by-tc-name TC GRL:-
  coq.TC.db-for TC Inst,
  std.map Inst inst->gref GRL.

pred app-get-class i:term, o:term.
app-get-class (prod _ _ T) R :- pi x\ app-get-class (T x) R.
app-get-class (app [global T|_]) (global T) :- coq.TC.class? T. 

pred app-has-class i:term.
app-has-class T :- app-get-class T _. 

% input (âˆ€ a, b, c ... => app [A, B, ..., Last])
% returns Last 
pred get-last i:term, o:term.
get-last (prod _ _ Bo) R :-
  pi x\ get-last (Bo x) R.
get-last (app L) R :-
  std.last L R.

% TC preds are on the form tc-[PATH_TO_TC].tc-[TC-Name]
pred gref->string-no-path i:gref, o:string.
gref->string-no-path Gr S :-
  if (coq.option.get ["TC_NameFullPath"] (coq.option.bool tt))
  (coq.gref->path Gr [Hd | Tl], 
  std.fold Tl Hd (x\acc\r\ r is acc ^ "." ^ x) Path', 
  Path is Path' ^ ".tc-") 
  (Path = ""),
  S is "tc-" ^ Path ^ {coq.gref->id Gr}.

pred make-tc i:term, i:term, i:list prop, o:prop.
make-tc Ty Inst Hyp Clause :-
  app [global TC | TL] = Ty,
  gref->string-no-path TC TC_Str,
  std.append TL [Inst] Args, 
  coq.elpi.predicate TC_Str Args Q,
  % Hyp' = [if (coq.option.get ["DebugTC"] (coq.option.bool tt)) (coq.say Args) (true) | Hyp],
  if (Hyp = []) (Clause = Q) (Clause = (Q :- Hyp)).
  % Clause = (Q :- Hyp').


pred get-inst-prio-coq i:term, i:list term, o:int.
get-inst-prio-coq (prod _ _ A) L Prio :-
  pi x\ get-inst-prio-coq (A x) [x | L] Prio.
get-inst-prio-coq (app _ as App) L Prio :-
  std.fold L 0 (T\acc\r\ if (not(occurs T App)) (r is acc + 1) (r = acc)) Prio.
get-inst-prio-coq A _ _ :- coq.error "Invalid case for" A.

% returns the priority of an instance from the gref of an instance
pred get-inst-prio i:gref, o:int.
get-inst-prio InstGr Prio :-
  coq.env.typeof InstGr InstTy,
  get-TC-of-inst-type InstTy TC,
  find-opt {coq.TC.db-for TC} 
    (x\ tc-instance InstGr Prio' = x) (some _), !,
  if (Prio' = 0) (get-inst-prio-coq InstTy [] Prio) (Prio = Prio').
get-inst-prio _ 0.

% TODO: @FissoreD improve this method complexity
pred get-full-path i:gref, o:string.
:if "get-full-path"
get-full-path Gr Res' :-
  coq.gref->string Gr Path,
  coq.env.current-section-path SectionPath,
  std.fold SectionPath "" (e\acc\r\ r is acc ^ "." ^ e) Res,
  Res' is Res ^ Path.
get-full-path _ _.