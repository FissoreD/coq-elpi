namespace tc {
  namespace link {
    pred relocate i:list term, i:list term, i:term, o:term.
    relocate [] [] T T' :- copy T T'.
    relocate [X|Xs] [Y|Ys] T T' :- (copy Y X :- !) => relocate Xs Ys T T'.

    pred get-vars i:term, o:list term.
    get-vars T R :-
      (pi X H L Ign\ fold-map X L X [H|L] :- var X H Ign, !) => 
        fold-map T [] _ R.

    pred split-pf i:list term, i:list term, o:list term, o:list term.
    split-pf [] _ [] [] :- !.
    split-pf [X|Xs] Old [X|Ys] L :- name X, not (std.mem! Old X), !, split-pf Xs [X|Old] Ys L.
    split-pf Xs _ [] Xs.

    % [build-eta-llam-links.aux LHS Scope Ty Names PF NPF OldLinks NewVar NewLinks]
    :index(_ _ _ _ 3)
    pred build-eta-llam-links.aux i:term, i:list term, o:term, i:list term, i:list term, i:list term, i:list prop, o:term, o:list prop.
    build-eta-llam-links.aux LHS _ _       Names []  NPF OL HD [llam T (app [LHS | NPF]) | OL] :- !,
      std.assert! (not (NPF = [])) "[TC] NPF List should not be empty",
      prune T Names,
      var T HD _. 
    build-eta-llam-links.aux LHS SC (prod _ Ty _)       _    [X] []  OL HD [eta LHS (fun `_` Ty (x\ V x)) | OL] :- !,
      prune V SC, var (V X) HD _.
    build-eta-llam-links.aux LHS SC (prod _ Ty Bo) Names [X|XS] NPF OL HD [eta LHS (fun `_` Ty (x\ LHS' x)) | L] :- !,
    % TODO: unfold Ty if needed...
      std.append SC [X] SC',
      prune LHS' SC, build-eta-llam-links.aux (LHS' X) SC' (Bo X) Names XS NPF OL HD L.
    build-eta-llam-links.aux LHS SC Ty Names ([_|_] as PF) NPF OL HD L :-
      Ty' = prod _ _ _, coq.unify-eq Ty Ty' ok, !,
      build-eta-llam-links.aux LHS SC Ty' Names PF NPF OL HD L.
    
    % [build-eta-llam-links T OldLinks X NewLinks]  
    % T = app[(uvar _ Scope) | S] this term is problematic and asks for the
    % creation of eta- and/or llam-links. Below some examples:

    % eta: when compiling t = (app [X, x, y]) and [x,y] are distinct_names, then
    %     the coq variable has not [x,y] in scope: it is applied to them.  
    %     The solution is to build the following links:  
    %     NewLinks = [X =η (λa.Y a),     a |- Y a =η (λb.Z a b)]
    %     and the exposed variable is G, given by `var G Z [x, y]`

    % llam: when compiling t = (app [X, a, x]) where a is a constant and x a
    %       name, we build a llam link.  
    %       The link will be: NewLinks ] = [T x =L X a x]  
    %       and the exposed variable is G, given by `var G T [x]`

    % eta-llam: here a combination of eta and llam:  
    %       let t = (app [X x y, z, c, w, d]) where X is a coq var with x and y
    %       in scope, z and w are names and c, d are constants.  
    %       In this case, the links should be:  
    %       NewLinks = [X x y =η (λa.Y x y a),   a |- Z x y a w =L (app[Y x y a, c w d])]  
    %       and the exposed variable is G, given by `var Z T [x, y, z, w]`  
    pred build-eta-llam-links i:term, i:list prop, o:term, o:list prop.
    build-eta-llam-links (app[(uvar _ Scope as V) | S] as T) Links G NewLinks :- !,
      coq.typecheck V Ty ok,
      split-pf S Scope PF NPF,
      free-names T Names,
      build-eta-llam-links.aux V Scope Ty Names PF NPF Links LhsHd NewLinks,
      prune G Names,
      var G LhsHd Names.
    build-eta-llam-links T _ _ _ :- coq.error "[TC] invalid call to build-eta-llam-links:" T.

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % ETA LINK                                                                 %
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    namespace eta {
      pred eta-expand i:term, o:term.  
      eta-expand T1 (fun _ _ B) :- (name T1; is-coq-term T1), !, pi x\ coq.mk-app T1 [x] (B x). 
      eta-expand T1 (fun _ _ R) :- pi x\ name (R x) T1 [x].

      :index (_ _ 1)
      pred may-contract-to i:list term, i:term, i:term.
      may-contract-to _ N N :- name N, !.
      may-contract-to L N V :- var V _ S, !,
          std.forall [N|L] (x\ exists! S (may-contract-to [] x)).
      may-contract-to L N (app [N|A]) :-
        std.length A {std.length L},
        std.forall2 {std.rev L} A (may-contract-to []).
      may-contract-to L N (fun _ _ B) :-
        pi x\ may-contract-to [x|L] N (B x).

      pred occurs-rigidly i:term, i:term.
      occurs-rigidly N N :- name N, !.
      occurs-rigidly _ V :- var V, !, fail.
      occurs-rigidly N (app A) :- exists! A (occurs-rigidly N).
      occurs-rigidly N (fun _ _ B) :- pi x\ occurs-rigidly N (B x).

      pred maybe-eta-aux i:term, i:list term.
      maybe-eta-aux V L :- var V _ S, std.forall L (std.mem! S).
      maybe-eta-aux (app [_|A]) L :-
        SplitLen is {std.length A} - {std.length L},
        split-at-not-fatal SplitLen A HD TL,
        std.forall L (x\ not (exists! HD (occurs-rigidly x))),
        std.forall2 {std.rev L} TL (may-contract-to []). 
      maybe-eta-aux (fun _ _ B) L :-
        pi x\ maybe-eta-aux (B x) [x|L].

      pred maybe-eta i:term.
      maybe-eta (fun _ _ B) :- pi x\ maybe-eta-aux (B x) [x].

      pred unify-left-right i:term, i:term.
      unify-left-right (fun _ _ A) (fun _ _ A') :- !, pi x\ unify-left-right (A x) (A' x).
      unify-left-right A (fun _ _ _ as T) :- !, eta-expand A Ae, pi x\ unify-left-right Ae T.
      unify-left-right A A' :- A = A'.

      pred progress-eta-left i:term, o:term.
      progress-eta-left A _ :- var A, !, fail.
      progress-eta-left (fun _ _ A) (fun _ _ A).
      progress-eta-left A A' :- (name A; is-coq-term A), !, eta-expand A A'.

      pred progress-eta-right i:term, o:term.
      progress-eta-right (fun _ _ B as T) T :- pi x\ var (B x), !, fail.
      progress-eta-right A A' :- coq.reduction.eta-contract A A', not (A = A'), !.
      progress-eta-right A A :- not (maybe-eta A), !.

      pred scope-check i:term, i:term.
      scope-check (uvar _ L) T :- prune A L, A = T, !.

      pred collect-store o:list prop.
      pred collect-store-aux i:list prop, o:list prop.

      collect-store L :- collect-store-aux [] L.
      collect-store-aux X L :- declare_constraint (collect-store-aux X L) [_].

      pred unify-eta i:term, i:term.
      % unify-eta A B :- coq.say "Unify-eta" "A"A"B"B, fail.
      unify-eta (uvar _ _ as A) B :- !, A = B, !.
      unify-eta (fun _ _ A) (fun _ _ B) :- !, pi x\ unify-eta (A x) (B x).
      unify-eta A (fun _ _ _ as B) :- !, eta-expand A A', unify-eta A' B.
      unify-eta A B :- A = B.

      constraint eta solve-eta {
        rule solve-eta \ (eta A B) <=> (unify-eta A B).
        rule \ solve-eta.
        % If two eta links have same lhs they rhs should unify
        rule (N1 : G1 ?- eta (uvar X L1) (fun _ T1 B1)) 
            \ (N2 : G2 ?- eta (uvar X L2) (fun _ T2 B2)) 
            | (pi x\ relocate L1 L2 (B2 x) (B2' x))  
        <=> (N1 : G1 ?- B1 = B2').
      }

      pred eta i:term, i:term.
      eta _ B :- var B, coq.error "[TC] link.eta error, flexible rhs".
      eta A (fun _ _ B as T) :- not (var A), not (var B), !, unify-left-right A T. 
      eta A B :- progress-eta-right B B', !, A = B'. 
      eta A B :- progress-eta-left A A', !, A' = B.
      eta A B :- scope-check A B, get-vars B Vars, declare_constraint (eta A B) [_,A|Vars].
    }

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % LLAM LINK                                                                %
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    namespace llam {
      pred llam i:term, i:term.
      llam A (uvar _ S as T) :- distinct_names S, !, A = T.
      llam A (app [H|L] as T) :- var A, var H, !, get-vars T Vars, 
        declare_constraint (llam A (app [H|L])) [_,A|Vars].
      llam (fun _ _ _ as F) (app [H | TL]) :- 
        var H _ Scope, !, 
          std.drop-last 1 TL TL', 
          H = fun _ _Ty (x\ Bo'),  % TODO give a valid _Ty: should be: (Ty of dropped -> Ty of F)
          prune H' Scope,
          coq.mk-app H' TL' Bo',
          pi x\ llam F Bo'.
      llam A B :- !, tc.unify-eq A B.

      constraint solve-llam llam {
        rule solve-llam \ (llam A B) <=> (A = B).
        rule \ solve-llam.
        % If two llam links have same lhs they rhs should unify
        rule (N1 : G1 ?- llam (uvar X L1) T1) 
            \ (N2 : G2 ?- llam (uvar X L2) T2) 
            | (pi x\ relocate L1 L2 T2 T2')  
        <=> (N1 : G1 ?- T1 = T2'). % TODO: instead of elpi unif, should use heuristics...
      }
    }

    namespace cs {
      pred reduce-cs i:term, i:term, i:term, i:constant.
      reduce-cs V (app [ProjT, T]) Record Proj :-
        coq.unify-eq T Record Err, Err = ok,
        Q = [coq.redflags.const Proj],
        coq.redflags.add coq.redflags.nored [coq.redflags.delta, coq.redflags.beta, coq.redflags.match | Q] RF,
        @redflags! RF => coq.reduction.lazy.whd (app [ProjT, Record]) V',
        not (V' = match _ _ _), !,
        cs V V'.
      reduce-cs V T _ _ :- V = T.

      pred cs i:term, i:term.
      cs T1 T2 :- not (var T1), !, coq.unify-eq T1 T2 ok.
      cs (uvar _ as V) (app [_, Arg] as T) :- not (ground_term Arg), !, get-vars T Vars, declare_constraint (cs V T) [_, V | Vars].
      cs (uvar _ as V) (app [HD, _Arg] as T) :- 
        tc.coercion-unify HD, !, 
        get-vars T Vars, declare_constraint (cs V T) [_, V | Vars].

      cs (uvar _ as V) (app [HD | _] as T) :- 
        if (HD = global (const Proj), tc.proj->record Proj Record)
          (reduce-cs V T Record Proj)
          (coq.unify-eq V T ok).
      cs T1 T2 :- not (T2 = app _), !, coq.unify-eq T1 T2 ok.

      pred unify-under-ctx i:list term, i:list term, i:term, i:term, i:term, i:term.
      unify-under-ctx [] [] A B V1 V2 :- copy A A', copy V1 V1', !, coq.unify-eq A' B ok, !, V1' = V2.
      unify-under-ctx [X|XS] [Y|YS] A B V1 V2:- (copy X Y :- !) => unify-under-ctx XS YS A B V1 V2.

      % TODO: there could be two same variables suspended on non unifyable
      % terms, this should be detected and raise a failure.
      % An example of this is in test/canonical_struct.v
      constraint cache def decl coq.unify-eq ?- solve-cs cs {
        rule solve-cs \ (Ctx ?- cs A B) <=> (Ctx => coq.unify-eq A B ok).
        rule (Ctx1 ?- cs (uvar A L1 as X) T1) \ (Ctx2 ?- cs (uvar A L2 as Y) T2) <=>
          (Ctx2 => unify-under-ctx L1 L2 T1 T2 X Y).
        rule \ solve-cs.
      }
    }

    namespace cs {
      pred cs i:term, i:term.
      % TODO: suspend link on vars in T
      cs V T :- var V, !, get-vars T Vars, declare_constraint (cs V T) [_, V | Vars].
      cs T1 T2 :- coq.unify-eq T1 T2 ok.

      % pred unify-rebinding-names i:list prop, i:list prop, i:term, i:term.
      % unify-rebinding-names [] T1 [] T2 (unify-eq T1V T2) :- !, copy T1 T1V.
      % unify-rebinding-names [N|NS] T1 [V|VS] T2 C :- !, copy N V => unify-rebinding-names NS T1 VS T2 C.
      % unify-rebinding-names [] T1 VS T2 C :- !, unify-rebinding-names [] {coq.subst-prod VS T1} [] T2 C. % FIXME: reduction
      % unify-rebinding-names [_|NS] (prod _ _ F) [] T2 C :- !,                      % FIXME: reduction
      %   assert! (pi x\ F x = F1) "restriction bug", unify-rebinding-names NS F1 [] T2 C.

      pred unify-under-ctx i:list term, i:list term, i:term, i:term, i:term, i:term.
      unify-under-ctx [] [] A B V1 V2 :- copy A A', copy V1 V1', !, coq.unify-eq A' B ok, !, V1' = V2.
      unify-under-ctx [X|XS] [Y|YS] A B V1 V2:- (copy X Y :- !) => unify-under-ctx XS YS A B V1 V2.

      % TODO: there could be two same variables suspended on non unifyable
      % terms, this should be detected and raise a failure.
      % An example of this is in test/canonical_struct.v
      constraint cache def decl coq.unify-eq ?- solve-cs cs {
        rule solve-cs \ (Ctx ?- cs A B) <=> (Ctx => coq.unify-eq A B ok).
        rule (Ctx1 ?- cs (uvar A L1 as X) T1) \ (Ctx2 ?- cs (uvar A L2 as Y) T2) <=>
          (Ctx2 => unify-under-ctx L1 L2 T1 T2 X Y).
        rule \ solve-cs.
      }
    }

    pred eta i:term, i:term.
    eta A B :- eta.eta A B.

    pred solve-eta.
    solve-eta :- declare_constraint solve-eta [_].

    pred llam i:term, i:term.
    llam A B :- llam.llam A B.

    pred solve-llam.
    solve-llam :- declare_constraint solve-llam [_].

    pred cs i:term, i:term.
    cs A B :- cs.cs A B.

    pred solve-cs.
    solve-cs :- declare_constraint solve-cs [_].
  }
}