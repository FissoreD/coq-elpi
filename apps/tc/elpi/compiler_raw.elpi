/* license: GNU Lesser General Public License Version 2.1 or later           */
/* ------------------------------------------------------------------------- */

accumulate base.
accumulate tc_aux.

shorten precompilation.{instance-clause, instance-lambda, instances, raw-clause, body-prop, body-raw}.

namespace precompilation {
  /*
  [compile-aux-preprocess InstType InstTerm UnivL UnivInstL Clause]
  InstType    : the type of the current instance
  InstTerm    : the term corresponding to the current instance
  UnivL       : the list of universal variable to be replaced with elpi fresh variables
  UnivInstL   : the list of universal instances to be replaced with elpi fresh variables
  Clause      : the clause corresponding to the current instace
  */
  pred compile-aux-preprocess i:term, i:term, i:list univ, i:list univ-instance, o:raw-clause.
  compile-aux-preprocess InstType InstTerm [] [] Clause :-
    copy InstType InstType', !,
    compile-aux InstType' InstTerm [] [] tt Clause.
  compile-aux-preprocess InstType InstTerm [Univ | UnivL] UnivInstL (instance-lambda (x\ Clause x)) :-
    pi x\ copy (sort (typ Univ)) (/*sort (typ x)*/ x) => 
      compile-aux-preprocess InstType InstTerm UnivL UnivInstL (Clause x).
  compile-aux-preprocess InstType InstTerm [] [UnivInst | UnivInstL] (instance-lambda (x\ Clause x)) :-
    pi x\ copy (pglobal A_ UnivInst) (/*pglobal A x*/ x) => 
      compile-aux-preprocess InstType InstTerm [] UnivInstL (Clause (/*(pglobal A x)*/x)).

  /*
  [compile-aux InstType InstTerm Premises PiAccRev IsPositive Clause]
  InstType    : the type of the instance
  InstTerm    : the term corresponding to the current instance
  Premises    : list of constraints/premises of an instances found from its type
  PiAccRev    : the list of pi variables accumulated from the (prod _ _ Bo) of the 
                type of Inst. The will be used on the solution of the clause
                coq.mk-app Inst {std.rev PiAccRev} Sol
  IsPositive  : bring the information about the positivity of the current sub-term
                e.g. if T = A -> (B -> C) -> D, then:
                D is positive in T, (B -> C) is negative, A is positive in T
                C is positivie in (B -> C), B is negative in (B -> C)
                IsPositive is used to know how to accumulate sigma Xi\ and pi x\ in the 
                current clause 
  Clause      : the solution to be returned
  */
  pred compile-aux i:term, i:term, i:list raw-clause, i:list term, i:bool, o:raw-clause.
  :name "compiler-aux:start"
  compile-aux (prod N_ T F) I RevPremises ListVar IsPositive Clause :- !,
    (if (IsPositive = tt) (Clause = instance-lambda (x\ C x)) (Clause = (instance-lambda (x\ /*decl x N T =>*/ C x)))),
    pi p\ sigma NewPremise TC L\ 
      if (get-TC-of-inst-type T TC, coq.TC.class? TC /*, not (occurs p (F p))*/) 
        (compile-aux T p [] [] {neg IsPositive} NewPremise,
        if (true /*class TC _ deterministic*/) 
          (L = [/*do-once*/ NewPremise | RevPremises])
          (L = [NewPremise | RevPremises])) (L = RevPremises),
      compile-aux (F p) I L [p | ListVar] IsPositive (C p).
  compile-aux Ty I RevPremises ListVar _ Clause :- 
    not (is-option-active oTC-use-pattern-fragment-compiler), !,
    std.rev RevPremises Premises,
    coq.mk-app I {std.rev ListVar} Proof,
    coq.mk-app Ty [Proof] Head,
    Clause = (instance-clause Head {std.map Premises (x\r\ r = body-raw x)}).

  % build a list of Clauses of type tc to be temporarly added to the 
  % database, used in theorems having assumptions.
  % pred compile-ctx i:goal-ctx, o:list prop.
  % compile-ctx [] [].
  % compile-ctx [X | Xs] [Clause | ResTl] :-
  %   (decl Var _ Ty = X; def Var _ Ty _ = X),
  %   is-instance-term Ty,
  %   compile-ty Ty Var _ Clause,
  %   compile-ctx Xs ResTl.
  % compile-ctx [_ | Tl] L :- compile-ctx Tl L.

  pred get-univ-instances i:term, o:list univ-instance.
  get-univ-instances T L :-
    (pi x L\ fold-map (pglobal _ x) L _ [x | L]) => fold-map T [] _ L.

  pred get-univ i:term, o:list univ.
  get-univ T L :-
    coq.univ.variable.set.elements {coq.univ.variable.of-term T} Vars,
    std.map Vars (x\r\ coq.univ.variable r x) L.

  pred compile-ty i:term, i:term, o:gref, o:raw-clause.
  compile-ty Ty Inst TC-of-Inst Clause:-
    get-TC-of-inst-type Ty TC-of-Inst,
    @redflags! coq.redflags.beta => coq.reduction.lazy.norm Ty Ty1, 
    get-univ Ty1 UnivConstL,
    get-univ-instances Ty1 UnivInstL,
    compile-aux-preprocess Ty1 Inst UnivConstL UnivInstL Clause.

  pred compile i:gref, o:gref, o:raw-clause.
  compile InstGR TC-of-Inst Clause:-
    coq.env.typeof InstGR Ty,
    compile-ty Ty (global InstGR) TC-of-Inst Clause.

  pred has-context-deps i:gref.
  has-context-deps GR :-
    coq.env.section SectionVars,
    coq.env.dependencies GR _ Deps, 
    std.exists SectionVars (x\ coq.gref.set.mem (const x) Deps).

  pred get-locality i:string, o:list prop.
  get-locality "Local" [@local!].
  get-locality _ [@local!] :- coq.env.current-section-path [_ | _].
  get-locality "Global" [@global!].
  get-locality "Export" [].

  pred add-inst.aux i:gref, i:gref i:list prop, i:grafting.
  add-inst.aux Inst TC Locality Grafting :-
    % coq.env.current-section-path SectionPath,
    compile Inst TC Clause,
    Locality => (
      add-tc-db _ Grafting (instances Clause)
      % add-tc-db _ Grafting (instance SectionPath Inst TC)
      ).
  add-inst.aux Inst _ _ _ :- 
    @global! => add-tc-db _ _ (banned Inst),
    coq.error "TC_solver" "Cannot compile " Inst.

  pred add-inst i:gref, i:gref, i:string, i:int.
  add-inst Inst TC LocalityStr Prio :-
    get-locality LocalityStr Locality,
    if (Prio = -1) (get-inst-prio Inst Prio1) (Prio1 = Prio),
    Grafting is after (int_to_string Prio1),
    add-inst.aux Inst TC Locality Grafting.

  pred is-local.
  is-local :- std.mem {attributes} (attribute "local" _).

  % [add-inst->db ForceAdd Inst] compiles and add Inst to the db
  pred add-inst->db i:bool, i:gref.
  :name "add-inst->db:start"
  add-inst->db ForceAdd Inst :-
    if ((ForceAdd = tt; not (instance _ Inst _)), not (banned Inst)) 
    (Grafting is after (int_to_string {get-inst-prio Inst}),
      get-TC-of-inst-type {coq.env.typeof Inst} TC,
      if (is-local; has-context-deps Inst) (Locality = [@local!]) (Locality = [@global!]),
      add-inst.aux Inst TC Locality Grafting)
    true /* true: the instance has already been added or is banned */.

  % add all the instances of a TC
  pred add-inst-of-tc i:gref.
  add-inst-of-tc GR:-
    get-inst-by-tc-name GR InstL,
    std.forall InstL (add-inst->db ff).

  pred add-tc-or-inst-gr i:list gref.
  add-tc-or-inst-gr Names :-
    std.forall Names (GR\
      if2 (coq.TC.class? GR)(add-inst-of-tc GR)
          (is-instance-gr GR)(add-inst->db ff GR)
          (coq.warning "not-inst-nor-tc" "TC-warning" GR "is neither a TC nor a instance")
    ).

  % [add-tc-or-inst IgnoreDepClass ClassName] look
  % for all the instances of ClassName and call the pred
  % add-inst->db
  pred add-tc-or-inst i:list string.
  add-tc-or-inst Names :-
    std.map Names coq.locate L,
    add-tc-or-inst-gr L.

  % takes a Path and a GR and returns if 
  % the GR is located in Path
  pred is-in-path i:string, i:gref. 
  is-in-path Path GR :- 
    std.mem {coq.gref->path GR} Path.

  % Look for the instances of ClassName 
  % that are located in Path.
  pred add-path i:string, i:string.
  add-path ClassName Path :-
    coq.locate ClassName GR,
    std.filter {get-inst-by-tc-name GR} (is-in-path Path) InstInPath,
    std.forall InstInPath (add-inst->db ff).
}