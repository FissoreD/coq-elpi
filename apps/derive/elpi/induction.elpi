/* induction principles                                                      */
/* license: GNU Lesser General Public License Version 2.1 or later           */
/* ------------------------------------------------------------------------- */

shorten std.{do!, assert!, last, appendR, rev, map}.

namespace derive.induction {

% local db associating to each constructor the hypothesis to be used
type induction-hyp-db term -> term -> prop.

pred informative. % loaded in the context if we can elim to Type

% create (paramX.prove (is_T params) P IH)
pred mk-paramX.prove-clause i:list term, i:term, i:term, i:term, o:prop.
mk-paramX.prove-clause [_] T P IH (param1-functor-db T P IH).

mk-paramX.prove-clause [_,_|Args] T P IH (pi x y\ C x y) :-
  pi x y\ mk-paramX.prove-clause Args {coq.mk-app T [x,y]} {coq.mk-app P [x,y]} {coq.mk-app IH [x,y]} (C x y).

% branch for constructor k is (hyp-k ...) where ... are the terms
% generated by prove-args
pred branch i:term, i:term, i:list term, i:list term, o:term. 
branch K _ V VT R :-
  induction-hyp-db K IH,
  ((pi H G P\ paramX.prove H G P :- param1-functor-db H G P) ==>
   (pi X\ paramX.cross X) ==>
    paramX.prove-args V VT Args),
  coq.mk-app IH Args R.

pred oty i:term, i:list term, i:list term, o:term.
oty _ _ VT P :-
  last VT XT,
  copy XT P.

pred branches i:term, i:term, i:list term, i:term, i:int, o:int, o:term, o:term.
branches (prod Name S T) Ity Args IH N M (prod Name S F1) (fun Name S R1) :- !,
  @pi-decl Name S x\
    branches (T x) Ity [x|Args] IH {calc (N + 1)} M (F1 x) (R1 x).

branches (sort _) Ity Args IH Rno Rno Fty (fun `x` ItyArgs Bo) :- do! [
  coq.mk-app Ity {rev Args} ItyArgs,
  copy ItyArgs PArgs,
  Fty = prod `x` ItyArgs (_\ PArgs),
  copy Ity P,
  mk-paramX.prove-clause Args Ity P IH C,
  @pi-decl `x` ItyArgs x\
    C =>
    coq.build-match x ItyArgs oty branch (Bo x)
].

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Synthesize the type of each hypothesis starting from the type
% of the constructor of is_T

pred hyp i:term, o:term.
hyp (prod N S T) (prod N Q R) :- !,
  copy S Q,
  @pi-decl N Q x\ hyp (T x) (R x).
hyp S Q :- copy S Q.

pred hyps i:list term, i:list term, i:term, i:term, o:term.
hyps [K|KS] [KT|KTS] Ity Arity (fun Name Ind Bo) :-
  coq.term->gref K GRK,
  coq.name-suffix `H` {coq.gref->id GRK} Name,
  hyp KT Ind, !, % we cut since copy generates many solutions
  @pi-decl `Name` Ind x\
    induction-hyp-db K x => % This is the hyp to be used for branch K
    hyps KS KTS Ity Arity (Bo x).

hyps [] [] Ity Arity (fix `IH` Recno Fty Bo) :-
  @pi-decl `IH` Fty f\ sigma C\
    branches Arity Ity [] f 0 Recno Fty (Bo f).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Parameters and the P of the induction predicate (truncated wrt the type
% of the unary parametricity translation, eg P takes only the indexes)

pred truncated-predicate-ty i:term, o:term.
truncated-predicate-ty (sort _) T :- informative, !,
  T = sort (typ U), coq.univ.new U.
truncated-predicate-ty (sort _) (sort prop).

truncated-predicate-ty (prod N S T) (prod N S R) :-
  @pi-decl N S x\ truncated-predicate-ty (T x) (R x).
  
% loads the context with the substitution "is_T params -> P"
pred mk-subst-clause i:term, i:term, o:list prop.
mk-subst-clause Ity P C :-
 coq.safe-dest-app Ity IT ITArgs,
 C = [(copy IT P :- !),
      (pi Args Rest O\
        copy (app[IT|Args]) O :- !, appendR ITArgs Rest Args, coq.mk-app P Rest O, !)].

pred params i:int, i:term, i:list term, i:list term, i:term, o:term.
params N Ity K KT (prod Nx Sx x\ prod NP (SP x) (T x)) (fun Nx Sx x\ fun NP (SP x) (R1 x)) :- N > 0, !,
  M is N - 2,
  @pi-decl Nx Sx x\
  @pi-decl NP (SP x) px\
    % useless, the identity map is already there
    % paramX.prove px px (fun `x` x a\ fun `pa` (app[px,a]) pa\ pa) =>
    params M
      {coq.mk-app Ity [x,px]}
      {map K (k\ coq.mk-app k [x,px])}
      {map KT (coq.subst-prod [x,px])}
      (T x px) (R1 x px).

params 0 Ity K KT Arity (fun `P` Pty p\ Bo p) :-
  % P only takes the indexes of Arity
  truncated-predicate-ty Arity Pty,
  @pi-decl `P` Pty p\ sigma Subst\
    (mk-subst-clause Ity p Subst,
     % replace (is_T params) with P
     Subst =>
       hyps K KT Ity Arity (Bo p)).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

func main inductive, string -> list prop.
main GR Prefix [Clause] :- do! [
  T = global (indt GR),

  if (coq.env.informative? GR) (Informative = [informative]) (Informative = []),

  assert! (reali T TR) {calc (
    "derive.induction: no unary parametricity translation for" ^
    {coq.term->string T} ^ ", use derive.param1 first")},
  TR = global (indt GRR),
  coq.env.indt GRR Ind Lno _ Arity K KT,
  assert! (Ind = tt) "derive.induction: Coinductive types are not supported",

  % we build the induction principle
  Informative => params Lno TR {std.map K (k\r\ r = global (indc k))} KT Arity R,
  % coq.say {coq.term->string R},
  std.assert-ok! (coq.typecheck R RT) "derive.induction generates illtyped term",

  Name is Prefix ^ "induction",
  coq.ensure-fresh-global-id Name FName,
  coq.env.add-const FName R RT _ I,

  % we register it as a clause
  Clause = (induction-db GR (global (const I)) :- !),
  coq.elpi.accumulate _ "derive.induction.db" (clause _ (before "induction-db:fail") Clause)
].

}
