accumulate base.
accumulate tc_aux.

shorten precompilation.{instance-clause, instance-lambda}.

namespace generalize_evar {
    % we add a new constructor to terms to represent terms to be abstracted
  type abs int -> term.

  pred copy-instance-clause i:instance-clause, o:instance-clause.
  copy-instance-clause (instance-clause A B) (instance-clause A' B') :- copy A A', std.map B copy B'.
  copy-instance-clause (instance-lambda A) (instance-lambda A') :-
    pi x\ copy-instance-clause (A x) (A' x).

  pred fold-map-instance-clause i:instance-clause, i:A, o:instance-clause, o:A.
  fold-map-instance-clause (instance-clause A B) C (instance-clause A' B') C' :-
    std.fold-map [A | B] C fold-map [A' | B'] C'.
  fold-map-instance-clause (instance-lambda A) C (instance-lambda A') C' :-
    pi x\ fold-map-instance-clause (A x) C (A' x) C'.


  % bind back abstracted subterms
  pred bind i:int, i:int, i:instance-clause, o:instance-clause.
  bind I M T T1 :- M > I, !,
    T1 = instance-lambda B,
    N is I + 1,
    pi x\                           % we allocate the fresh symbol for (abs M)
      (copy (abs N) x :- !) =>      % we schedule the replacement (abs M) -> x
      bind N M T (B x).
  bind M M T T1 :- copy-instance-clause T T1', T1 = T1'.         % we perform all the replacements

  % for a term with M holes, returns a term with M variables to fill these holes
  % the instance-clause see is only generated for a term if it hasn't been seen before
  % the term might need to be typechecked first or main generates extra holes for the
  % type of the parameters
  pred abs-evars i:instance-clause, o:instance-clause, o:int.
  abs-evars T1 T3 M :- std.do! [
    % we put (abs N) in place of each occurrence of the same hole
    (pi T Ty N N' M \ fold-map T N (abs M) M :- var T, not (seen? T _), !, M is N + 1, seen! T M) =>
    (pi T N M \ fold-map T N (abs M) N :- var T, seen? T M, !) =>
      fold-map-instance-clause T1 0 T2 M,
    % we abstract M holes (M abs nodes)
    bind 0 M T2 T3,
    % cleanup constraint store
    purge-seen!,
  ].

  % all constraints are also on _ so that they share
  % a variable with the constraint to purge the store

  % we query if the hole was seen before, and if so
  % we fetch its number
  pred seen? i:term, o:int.
  seen? X Y :- declare_constraint (seen? X Y) [X,_].

  % we declare it is now seen and label it with a number
  pred seen! i:term, i:int.
  seen! X Y :- declare_constraint (seen! X Y) [X,_].

  % to empty the store
  pred purge-seen!.
  purge-seen! :- declare_constraint purge-seen! [_].

  constraint seen? seen! purge-seen!  {
    % a succesful query, give the label back via M
    rule (seen! X N) \ (seen? X M) <=> (M = N).
    % an unsuccesful query
    rule             \ (seen? X _) <=> false.

    rule purge-seen! \ (seen! _ _).
    rule \ purge-seen!.
  }
}

pred findall-arity-one i:(A -> prop), o:list A.
findall-arity-one P R :-
  std.findall (P _) L,
  std.map L (x\r\ x = P r) R.

pred destruct-instance-clause i:instance-clause, o:term, o:list term.
destruct-instance-clause (instance-clause A B) A B.
destruct-instance-clause (instance-lambda A) B C :- sigma x\ destruct-instance-clause (A x) B C.

pred entry-point i:int, i:list instance-clause i:list instance-clause, i:term, o:instance-clause.
entry-point Depth [HD|_] P T (instance-clause T New-Hyps) :-
  destruct-instance-clause HD Hd Tl, Hd = T,
  precompile-list Depth P Tl New-Hyps.
entry-point Depth [_|TL] P T R :-
  entry-point Depth TL P T R.


% [precompile-list Depth Program Hyps R]
% - Depth is the depth of search
% - Program is the list of instance-clauses of the program
% - Hyps is the list of premisis of a instance-clause
% - R is the list of new premisis
pred precompile-list i:int, i:list instance-clause, i:list term, o:list term.
precompile-list _ _ [] [] :- !.
precompile-list 0 _ P P :- !.
precompile-list Depth P [H0 | Hyps] R :-
  Depth > 0,
  Depth1 is Depth - 1,
  solve-hyp-loop Depth1 P P H0 HD,
  precompile-list Depth1 P Hyps TL,
  std.append HD TL R.

% [solve-hyp-loop Depth Program ProgramMem Hyp Res]
% Solve the current Hyp by looping to the current program, ProgramMem
% is the entire program and is used to do the recursive calls
pred solve-hyp-loop i:int, i:list instance-clause, i:list instance-clause, i:term, o:list term.
% TODO: following rules should be applied only if no other solution is possible
solve-hyp-loop _ [] _ HD [HD] :- !.
solve-hyp-loop Depth [HD|_] P Hyp R :- solve-hyp Depth P HD Hyp R.
solve-hyp-loop Depth [_|TL] P Hyp R :- solve-hyp-loop Depth TL P Hyp R.

% [solve-hyp Depth Program Currentinstance-clause CurrentHyp Res]
% Tries to solve CurrentHyp with the Currentinstance-clause and gives
% back Res, that is the list of remaining hypothesis
pred solve-hyp i:int, i:list instance-clause, i:instance-clause, i:term, o:list term.
solve-hyp Depth P (instance-clause Head Hyps) Hd Res :- !,
  % print "the head is" Head "and the hyps is" Hyps "with head" Hd,
  Head = Hd,
  % print "------------------------------------ the head match ------------------------------------",
  precompile-list Depth P Hyps Res.
  % print "Should be at least one time".
solve-hyp Depth P (instance-lambda F) Hd Res :-
  solve-hyp Depth P (F D_) Hd Res.

pred term->prop i:term, o:prop.
term->prop T P :-
  coq.safe-dest-app T (global ClassGR) Args,
  gref->pred-name ClassGR ClassName,
  coq.elpi.predicate ClassName Args P.

pred instance-clause->prop i:instance-clause, o:prop.
instance-clause->prop (instance-clause Head PremiseTerms) Clause :-
  coq.safe-dest-app Head (global ClassGR) ArgTerms,
  gref->pred-name ClassGR ClassName,
  std.map ArgTerms term->prop Args,
  std.map PremiseTerms term->prop Premises,
  coq.elpi.predicate ClassName Args Q,
  if2 (Premises = []) (Clause = Q)
      (Premises = [Hd]) (Clause = (Q :- Hd))
      (Clause = (Q :- Premises)).

type tp term -> prop.

pred prod->fresh-vars i:term, o:prop.
prod->fresh-vars (prod _ _ A) (pi x\ F x) :- !,
  pi x\ prod->fresh-vars (A x) (F x).
prod->fresh-vars A (pi x\ B x) :- pi x\ coq.mk-app A x (L x), (B x) = tp (L x).

pred class_term_head i:gref, o:prop.
class_term_head GR T :-
  coq.env.typeof GR T', prod->fresh-vars T' T.

/*
  [precompile ClassGR Depth Rules] takes the gref of a class and a depth.
  After looking in the `precompilation.instances` database, we filter all the
  rules for ClassGR and precompile them with the given depth.
  TODO: maybe precompilation is done on a paricular argument to avoid exponential
        database
*/
pred precompile_class i:gref, i:int, o:list prop.
% precompile_class ClassGR Depth Rules :-
