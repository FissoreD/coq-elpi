% Contains the list of classes that
% cannot be compiled

% returns the TC from the type of an instance
pred get-TC-of-inst-type i:term, o:gref.
get-TC-of-inst-type (prod _ _ A) GR:-
  pi x\ get-TC-of-inst-type (A x) GR.
get-TC-of-inst-type (app [global TC | _]) TC.
get-TC-of-inst-type (global TC) TC.

pred remove-eta i:term, o:term.
remove-eta A B :- !,
  (pi F\ copy (fun _ _ x\ (app [F, x])) F) => copy A B.

pred drop-last i:list A, i:list A, o:list A.
drop-last [X | XS] [Y | YS] L :-
  same_term X Y, !, drop-last XS YS L.
drop-last L [] L' :- std.rev L L'.

pred remove-eta2.aux i:term, i:list term, o:term.
remove-eta2.aux (app [Hd | L]) V R :- !, std.do! [
  copy Hd Hd',
  std.map L copy L', 
  drop-last {std.rev L'} V F, 
  coq.mk-app Hd' F R].

remove-eta2.aux (fun _ _ Bo) L R :-
  pi x\ remove-eta2.aux (Bo x) [x | L] R.

pred remove-eta2 i:term, o:term.
remove-eta2 A B :- !,
  (pi A B\ copy A B :- remove-eta2.aux A [] B) => copy A B. 

pred instances-of-current-section o:list gref.
:name "MySectionEndHook"
instances-of-current-section InstsFiltered :-
  coq.env.current-section-path SectionPath,
  std.findall (instance SectionPath _ _) Insts,
  coq.env.section SectionVars,
  std.map-filter Insts (x\r\ sigma X\ instance _ r _ = x, const X = r, not(std.mem SectionVars X)) InstsFiltered.

pred is-instance-gr i:gref.
is-instance-gr GR :-
  coq.env.typeof GR Ty,
  is-instance-term Ty.

pred is-instance-term i:term.
is-instance-term T :-
  get-TC-of-inst-type T TC,
  coq.TC.class? TC.

% adds a clause to the tc.db DB at the passed grafting
pred add-tc-db o:id, o:grafting, i:prop.  
add-tc-db ClauseName Graft PR :-
  coq.elpi.accumulate _ "tc.db" 
    (clause ClauseName Graft PR); coq.error "cannot add " PR " to tc.db".

% takes a tc-instance and return the gref of the inst
pred inst->gref i:tc-instance, o:gref.
inst->gref (tc-instance Res _) Res.

% returns all the instances of the passed ClassName
pred get-inst-by-tc-name i:gref, o:list gref.
get-inst-by-tc-name TC GRL:-
  coq.TC.db-for TC Inst,
  std.map Inst inst->gref GRL',
  std.rev GRL' GRL. 

pred app-has-class i:term.
app-has-class T :- 
  get-TC-of-inst-type T Hd, 
  coq.TC.class? Hd. 

% input (âˆ€ a, b, c ... => app [A, B, ..., Last])
% returns Last 
pred get-last i:term, o:term.
get-last (prod _ _ Bo) R :-
  pi x\ get-last (Bo x) R.
get-last (app L) R :-
  std.last L R.

% TC preds are on the form tc-[PATH_TO_TC].tc-[TC-Name]
pred gref->string-no-path i:gref, o:string.
gref->string-no-path Gr S :-
  if (coq.option.get ["TC_NameFullPath"] (coq.option.bool tt))
  (coq.gref->path Gr [Hd | Tl], 
  std.fold Tl Hd (x\acc\r\ r is acc ^ "." ^ x) Path', 
  Path is Path' ^ ".tc-") 
  (Path = ""),
  S is "tc-" ^ Path ^ {coq.gref->id Gr}.

pred no-backtrack i:list prop, o:list prop. 
no-backtrack [] [].
no-backtrack [do X | XS] [std.do! [(std.do! X') | XS']] :- !, 
  no-backtrack X X', no-backtrack XS XS'.
no-backtrack [X | XS] [std.do! [X | XS']] :- !, no-backtrack XS XS'.

pred make-tc i:prop, i:term, i:term, i:list prop, o:prop.
make-tc _IsHead Ty Inst Hyp Clause :-
  coq.safe-dest-app Ty (global TC) TL,
  gref->string-no-path TC TC_Str,
  std.append TL [Inst] Args, 
  coq.elpi.predicate TC_Str Args Q,
  % if (classes TC deterministic, IsHead) (std.append [!] Hyp Hyp') (Hyp' = Hyp),
  if2 (Hyp = []) (Clause = Q) 
      (Hyp = [Hd]) (Clause = (Q :- Hd)) 
      (Clause = (Q :- Hyp)).

% This predicate wants to campute the priority of an instance as Coq would do
% This computation of the priority of an instance is shown here
% https://github.com/coq/coq/blob/f022d5d194cb42c2321ea91cecbcce703a9bcad3/tactics/hints.ml#L841
pred get-inst-prio-coq i:term, i:list term, o:int.
get-inst-prio-coq (prod _ _ A) L Prio :-
  pi x\ get-inst-prio-coq (A x) [x | L] Prio.
get-inst-prio-coq (app _ as App) L Prio :-
  std.fold L 0 (T\acc\r\ if (not(occurs T App)) (r is acc + 1) (r = acc)) Prio.
get-inst-prio-coq (global _) _ 0.
get-inst-prio-coq A _ _ :- coq.error "Invalid case for" A.

% returns the priority of an instance from the gref of an instance
pred get-inst-prio i:gref, o:int.
get-inst-prio InstGr Prio :-
  coq.env.typeof InstGr InstTy,
  get-TC-of-inst-type InstTy TC,
  find-opt {coq.TC.db-for TC} 
    (x\ tc-instance InstGr Prio' = x) (some _), !,
  if (Prio' = 0) (get-inst-prio-coq InstTy [] Prio) (Prio = Prio').
get-inst-prio _ 0.

% TODO: @FissoreD improve this method complexity
pred get-full-path i:gref, o:string.
% :if "get-full-path"
get-full-path Gr Res' :-
  coq.gref->string Gr Path,
  coq.env.current-section-path SectionPath,
  std.fold SectionPath "" (e\acc\r\ r is acc ^ "." ^ e) Res,
  Res' is Res ^ Path.
% get-full-path _ _.